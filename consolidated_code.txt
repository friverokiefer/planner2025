
----- ./consolidate_code.py -----
import os

# Nombre del archivo de salida
OUTPUT_FILE = "consolidated_code.txt"

# Directorios a excluir
EXCLUDED_DIRS = {"node_modules", ".git", "__pycache__", "venv", "user_data"}

# Extensiones de archivo a incluir
INCLUDED_EXTENSIONS = {".js", ".html", ".py"}

def consolidate_code():
    """
    Consolida el contenido de los archivos especificados en OUTPUT_FILE,
    excluyendo los directorios y extensiones definidos.
    """
    with open(OUTPUT_FILE, "w", encoding="utf-8") as output:
        for root, dirs, files in os.walk("."):
            # Filtrar directorios excluidos
            dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

            for file in files:
                # Procesar solo archivos con las extensiones incluidas
                if any(file.endswith(ext) for ext in INCLUDED_EXTENSIONS):
                    filepath = os.path.join(root, file)
                    # Escribir el encabezado del archivo
                    output.write(f"\n----- {filepath} -----\n")
                    try:
                        # Leer y escribir el contenido del archivo
                        with open(filepath, "r", encoding="utf-8") as f:
                            output.write(f.read())
                    except UnicodeDecodeError:
                        output.write("\n[Error: Archivo contiene caracteres no compatibles]\n")
                    except FileNotFoundError:
                        output.write("\n[Error: Archivo no encontrado]\n")
                    except Exception as e:
                        # Manejar otros errores de lectura
                        output.write(f"\n[Error inesperado: {e}]\n")
    print(f"\nEl c√≥digo consolidado ha sido guardado en {OUTPUT_FILE}")

if __name__ == "__main__":
    consolidate_code()

----- ./find_large_files.py -----
import os

# Funci√≥n para calcular el tama√±o de un archivo en bytes
def get_file_size(file_path):
    return os.path.getsize(file_path)

# Funci√≥n para listar todos los archivos en un directorio y subdirectorios
def list_all_files(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            yield os.path.join(root, file)

# Lista para almacenar los archivos grandes
large_files = []

# Umbral de tama√±o (en bytes) para considerar un archivo grande
large_file_threshold = 100 * 1024 * 1024  # 100 MB

# Recorrer todos los archivos en el repositorio
for file_path in list_all_files(os.getcwd()):
    # Obtener el tama√±o del archivo
    file_size = get_file_size(file_path)

    # Si el tama√±o del archivo supera el umbral, agregarlo a la lista
    if file_size >= large_file_threshold:
        large_files.append((file_path, file_size))

# Ordenar los archivos grandes por tama√±o de mayor a menor
large_files.sort(key=lambda x: x[1], reverse=True)

# Imprimir los archivos grandes en la terminal
for file_path, file_size in large_files:
    print(f"Ruta: {file_path}")
    print(f"Tama√±o: {file_size} bytes")
    print("----------------------------------------")
----- ./frontend/public/index.html -----
<!DOCTYPE html>
<html lang="en">
  <head>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Planner2025</title>
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
----- ./frontend/src/index.js -----
// frontend/src/index.js
import React from 'react';
import ReactDOM from 'react-dom/client'; // React 18
import App from './App';
import 'bootstrap/dist/css/bootstrap.min.css';

// Eliminamos <React.StrictMode> para evitar problemas con react-beautiful-dnd en desarrollo
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <App />
);

----- ./frontend/src/App.js -----
// frontend/src/App.js
import React, { useState, useEffect } from 'react';
import {
  BrowserRouter as Router,
  Routes,
  Route,
  NavLink,
  Navigate,
} from 'react-router-dom';

import TaskPage from './pages/TaskPage';
import ProfilePage from './pages/ProfilePage';
import ArchivedTasksPage from './pages/ArchivedTasksPage';
import TaskMetricsPage from './pages/TaskMetricsPage';
import FriendsPage from './pages/FriendsPage';
import HomePage from './pages/HomePage';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import AdminPage from './pages/AdminPage';
import './App.css';

import {
  FaTasks,
  FaUser,
  FaArchive,
  FaChartPie,
  FaHome,
  FaSignInAlt,
  FaUserPlus,
  FaUserShield,
} from 'react-icons/fa';

import authService from './services/authService';

function App() {
  const [user, setUser] = useState(undefined);
  const [theme, setTheme] = useState('default');
  const [profilePicUrl, setProfilePicUrl] = useState(null);

  // Cargar user y foto
  useEffect(() => {
    const currentUser = authService.getCurrentUser();
    if (!currentUser) {
      setUser(null);
    } else {
      setUser(currentUser);
      fetchProfilePic(currentUser.token);
    }
  }, []);

  const fetchProfilePic = async (token) => {
    try {
      const res = await fetch('/api/profile', {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (res.ok) {
        const data = await res.json();
        if (data.profile_picture_url) {
          setProfilePicUrl(data.profile_picture_url);
        }
      }
    } catch (err) {
      console.error('Error fetchProfilePic:', err);
    }
  };

  const handleLogin = (userData) => {
    setUser(userData);
    fetchProfilePic(userData.token);
  };

  const handleLogout = () => {
    authService.logout();
    setUser(null);
    setProfilePicUrl(null);
  };

  if (user === undefined) {
    return <div>Cargando sesi√≥n...</div>;
  }

  return (
    <div className={`app-container theme-${theme}`}>
      <Router>
        <header className="header">
          <h1>Planner2025{user ? ` ‚Äî ¬°Bienvenido, ${user.id}!` : ''}</h1>

          {/* Foto de perfil en el header (si existe) */}
          {profilePicUrl && (
            <img
              src={profilePicUrl}
              alt="Mi Perfil"
              style={{
                width: '40px',
                height: '40px',
                borderRadius: '50%',
                marginRight: '10px',
              }}
            />
          )}

          {/* Selector de tema */}
          <select value={theme} onChange={(e) => setTheme(e.target.value)}>
            <option value="default">Tema Default</option>
            <option value="dark">Tema Oscuro</option>
            <option value="pink">Tema Rosa</option>
          </select>

          <nav>
            <ul>
              <li>
                <NavLink
                  to="/"
                  className={({ isActive }) => (isActive ? 'active' : undefined)}
                >
                  <FaHome color="#ffffff" /> Home
                </NavLink>
              </li>

              {user ? (
                <>
                  <li>
                    <NavLink
                      to="/profile"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      <FaUser color="#ffffff" /> Profile
                    </NavLink>
                  </li>
                  <li>
                    <NavLink
                      to="/tasks"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      <FaTasks color="#ffffff" /> Tasks
                    </NavLink>
                  </li>
                  <li>
                    <NavLink
                      to="/archived"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      <FaArchive color="#ffffff" /> Archived
                    </NavLink>
                  </li>
                  <li>
                    <NavLink
                      to="/metrics"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      <FaChartPie color="#ffffff" /> Metrics
                    </NavLink>
                  </li>
                  <li>
                    <NavLink
                      to="/friends"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      Amigos
                    </NavLink>
                  </li>
                  {user.role === 'admin' && (
                    <li>
                      <NavLink
                        to="/admin"
                        className={({ isActive }) => (isActive ? 'active' : undefined)}
                      >
                        <FaUserShield color="#ffffff" /> Admin
                      </NavLink>
                    </li>
                  )}
                  <li>
                    <button onClick={handleLogout} className="logout-button">
                      Logout
                    </button>
                  </li>
                </>
              ) : (
                <>
                  <li>
                    <NavLink
                      to="/login"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      <FaSignInAlt color="#ffffff" /> Login
                    </NavLink>
                  </li>
                  <li>
                    <NavLink
                      to="/register"
                      className={({ isActive }) => (isActive ? 'active' : undefined)}
                    >
                      <FaUserPlus color="#ffffff" /> Register
                    </NavLink>
                  </li>
                </>
              )}
            </ul>
          </nav>
        </header>

        <div className="main-container">
          <Routes>
            <Route path="/" element={<HomePage />} />
            <Route
              path="/tasks"
              element={user ? <TaskPage /> : <Navigate to="/login" />}
            />
            <Route
              path="/profile"
              element={user ? <ProfilePage /> : <Navigate to="/login" />}
            />
            <Route
              path="/archived"
              element={user ? <ArchivedTasksPage /> : <Navigate to="/login" />}
            />
            <Route
              path="/metrics"
              element={user ? <TaskMetricsPage /> : <Navigate to="/login" />}
            />
            <Route
              path="/friends"
              element={user ? <FriendsPage /> : <Navigate to="/login" />}
            />

            <Route path="/login" element={<LoginPage onLogin={handleLogin} />} />
            <Route
              path="/register"
              element={<RegisterPage onLogin={handleLogin} />}
            />

            <Route
              path="/admin"
              element={
                user?.role === 'admin' ? <AdminPage /> : <Navigate to="/login" />
              }
            />
            <Route path="*" element={<Navigate to="/" />} />
          </Routes>
        </div>

        <footer className="footer">¬© 2025 Planner2025. Built with üíú</footer>
      </Router>
    </div>
  );
}

export default App;

----- ./frontend/src/components/RegisterForm.js -----
// frontend/src/components/RegisterForm.js
import React, { useState } from 'react';
import { Form, Button } from 'react-bootstrap';
import './RegisterForm.css'; // Aseg√∫rate de tener este archivo CSS

function RegisterForm({ onRegister }) {
  const [name, setName] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    onRegister({ name, email, password });
  };

  return (
    <Form onSubmit={handleSubmit} className="register-form">
      <Form.Group controlId="formBasicName">
        <Form.Label>Nombre</Form.Label>
        <Form.Control
          type="text"
          placeholder="Ingrese su nombre"
          value={name}
          onChange={(e) => setName(e.target.value)}
          required
        />
      </Form.Group>

      <Form.Group controlId="formBasicEmail">
        <Form.Label>Email</Form.Label>
        <Form.Control
          type="email"
          placeholder="Ingrese su email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </Form.Group>

      <Form.Group controlId="formBasicPassword">
        <Form.Label>Contrase√±a</Form.Label>
        <Form.Control
          type="password"
          placeholder="Ingrese su contrase√±a"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </Form.Group>

      <Button variant="primary" type="submit">
        Registrarse
      </Button>
    </Form>
  );
}

export default RegisterForm;

----- ./frontend/src/components/EditTaskModal.js -----
// frontend/src/components/EditTaskModal.js

import React, { useState, useEffect } from 'react';
import { Modal, Button, Form, Alert, Spinner } from 'react-bootstrap';
import './EditTaskModal.css';
import useSound from '../hooks/useSound';
import editProfileSound from '../assets/sounds/notification-1-269296.mp3';

function EditTaskModal({ show, handleClose, task, handleSave }) {
  const [updatedTask, setUpdatedTask] = useState({
    name: task.name || '',
    description: task.description || '',
    priority: task.priority || 'Low',
    difficulty: task.difficulty || 1, // Cambiado a n√∫mero
    status: task.status || 'Pending',
    estimated_time: task.estimated_time || '',
    actual_time: task.actual_time || '',
  });
  const [formError, setFormError] = useState('');
  const [formSuccess, setFormSuccess] = useState('');
  const [loading, setLoading] = useState(false);

  const playEditProfileSound = useSound(editProfileSound);

  useEffect(() => {
    setUpdatedTask({
      name: task.name || '',
      description: task.description || '',
      priority: task.priority || 'Low',
      difficulty: task.difficulty || 1, // Restablecido a n√∫mero
      status: task.status || 'Pending',
      estimated_time: task.estimated_time || '',
      actual_time: task.actual_time || '',
    });
    setFormError('');
    setFormSuccess('');
  }, [task, show]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    let newValue = value;

    // Convertir campos num√©ricos a n√∫meros
    if (name === 'difficulty') {
      newValue = parseInt(value, 10);
    } else if (name === 'estimated_time' || name === 'actual_time') {
      newValue = value === '' ? '' : parseFloat(value);
    }

    setUpdatedTask({ ...updatedTask, [name]: newValue });
  };

  const onSave = async () => {
    setFormError('');
    setFormSuccess('');

    // Validaci√≥n b√°sica
    if (!updatedTask.name.trim()) {
      setFormError('El nombre de la tarea es obligatorio.');
      return;
    }

    setLoading(true);

    try {
      const response = await fetch(`/api/tasks/${task.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(updatedTask),
      });

      if (response.ok) {
        const data = await response.json();
        handleSave(data);
        playEditProfileSound();
        setFormSuccess('Tarea actualizada exitosamente.');
        setTimeout(() => {
          handleClose();
        }, 1000);
      } else {
        const errorData = await response.json();
        setFormError(errorData.error || 'Error al actualizar la tarea.');
      }
    } catch (error) {
      console.error('Error al actualizar la tarea:', error);
      setFormError('Error al actualizar la tarea.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Modal show={show} onHide={handleClose} centered>
      <Modal.Header closeButton>
        <Modal.Title>Editar Tarea</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        {formError && <Alert variant="danger">{formError}</Alert>}
        {formSuccess && <Alert variant="success">{formSuccess}</Alert>}
        <Form>
          <Form.Group controlId="formTaskName">
            <Form.Label>Nombre</Form.Label>
            <Form.Control
              type="text"
              name="name"
              value={updatedTask.name}
              onChange={handleChange}
              placeholder="Ingrese el nombre de la tarea"
              required
            />
          </Form.Group>

          <Form.Group controlId="formTaskDescription" className="mt-3">
            <Form.Label>Descripci√≥n</Form.Label>
            <Form.Control
              as="textarea"
              rows={3}
              name="description"
              value={updatedTask.description}
              onChange={handleChange}
              placeholder="Ingrese una descripci√≥n opcional"
            />
          </Form.Group>

          <Form.Group controlId="formTaskPriority" className="mt-3">
            <Form.Label>Prioridad</Form.Label>
            <Form.Control
              as="select"
              name="priority"
              value={updatedTask.priority}
              onChange={handleChange}
            >
              <option>Low</option>
              <option>Medium</option>
              <option>High</option>
            </Form.Control>
          </Form.Group>

          <Form.Group controlId="formTaskDifficulty" className="mt-3">
            <Form.Label>Dificultad</Form.Label>
            <Form.Control
              as="select"
              name="difficulty"
              value={updatedTask.difficulty}
              onChange={handleChange}
            >
              <option value={1}>1 - F√°cil</option>
              <option value={2}>2 - Medio</option>
              <option value={3}>3 - Dif√≠cil</option>
            </Form.Control>
          </Form.Group>

          <Form.Group controlId="formTaskStatus" className="mt-3">
            <Form.Label>Estado</Form.Label>
            <Form.Control
              as="select"
              name="status"
              value={updatedTask.status}
              onChange={handleChange}
            >
              <option>Pending</option>
              <option>In Progress</option>
              <option>Completed</option>
            </Form.Control>
          </Form.Group>

          <Form.Group controlId="formTaskEstimatedTime" className="mt-3">
            <Form.Label>Tiempo Estimado (horas)</Form.Label>
            <Form.Control
              type="number"
              name="estimated_time"
              value={updatedTask.estimated_time}
              onChange={handleChange}
              placeholder="Ingrese el tiempo estimado"
              min="0"
              step="0.1"
            />
          </Form.Group>

          <Form.Group controlId="formTaskActualTime" className="mt-3">
            <Form.Label>Tiempo Real (horas)</Form.Label>
            <Form.Control
              type="number"
              name="actual_time"
              value={updatedTask.actual_time}
              onChange={handleChange}
              placeholder="Ingrese el tiempo real"
              min="0"
              step="0.1"
            />
          </Form.Group>
        </Form>
      </Modal.Body>
      <Modal.Footer>
        <Button variant="secondary" onClick={handleClose} disabled={loading}>
          Cancelar
        </Button>
        <Button variant="primary" onClick={onSave} disabled={loading}>
          {loading ? (
            <>
              <Spinner
                as="span"
                animation="border"
                size="sm"
                role="status"
                aria-hidden="true"
              />{' '}
              Guardando...
            </>
          ) : (
            'Guardar Cambios'
          )}
        </Button>
      </Modal.Footer>
    </Modal>
  );
}

export default EditTaskModal;

----- ./frontend/src/components/UserList.js -----

----- ./frontend/src/components/TaskItem.js -----
// frontend/src/components/TaskItem.js
import React, { useState } from 'react';
import './TaskItem.css';
import {
  FaTrashAlt,
  FaCheck,
  FaEdit,
  FaArchive,
  FaUndo,
  FaEllipsisV,
} from 'react-icons/fa';
import { Dropdown, Button, Alert } from 'react-bootstrap';
import EditTaskModal from './EditTaskModal';
import ConfirmModal from './ConfirmModal';
import useSound from '../hooks/useSound';
import completeSound from '../assets/sounds/notification-1-269296.mp3';
import deleteSound from '../assets/sounds/notification-2-269292.mp3';
import editSound from '../assets/sounds/notification-sound-3-262896.mp3';
import archiveSound from '../assets/sounds/intro-sound-2-269294.mp3';
import authService from '../services/authService';

function TaskItem({
  task,
  onComplete,
  onDelete,
  onEdit,
  onArchive,
  onUnarchive,
}) {
  const [showEditModal, setShowEditModal] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [actionError, setActionError] = useState('');

  const playCompleteSound = useSound(completeSound);
  const playDeleteSound = useSound(deleteSound);
  const playEditSound = useSound(editSound);
  const playArchiveSound = useSound(archiveSound);

  // Verificar que 'task' e 'id' existan
  if (!task || typeof task.id === 'undefined') {
    console.error('El objeto "task" o "task.id" es indefinido:', task);
    return null;
  }

  // Extraemos el token del usuario logueado (para todas las peticiones)
  const user = authService.getCurrentUser();
  const token = user?.token;

  // Completar Tarea
  const handleComplete = async () => {
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}/complete`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.ok) {
        const updatedTask = await response.json();
        if (onComplete) onComplete(updatedTask.id);
        playCompleteSound();
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al completar la tarea');
      }
    } catch (error) {
      console.error('Error al completar la tarea:', error);
      setActionError('Error al completar la tarea');
    }
  };

  // "Continuar" (poner status = "In Progress")
  const handleContinue = async () => {
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ status: 'In Progress' }),
      });
      if (response.ok) {
        const updatedTask = await response.json();
        if (onEdit) onEdit(task.id, updatedTask);
        playCompleteSound();
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al continuar la tarea');
      }
    } catch (error) {
      console.error('Error al continuar la tarea:', error);
      setActionError('Error al continuar la tarea');
    }
  };

  // Eliminar Tarea (confirma primero)
  const handleDelete = () => {
    setShowDeleteConfirm(true);
  };

  const confirmDelete = async () => {
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.ok) {
        if (onDelete) onDelete(task.id);
        playDeleteSound();
        setShowDeleteConfirm(false);
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al eliminar la tarea');
      }
    } catch (error) {
      console.error('Error al eliminar la tarea:', error);
      setActionError('Error al eliminar la tarea');
    }
  };

  // Guardar cambios del modal de edici√≥n
  const handleEditSave = (updatedTask) => {
    if (onEdit) onEdit(task.id, updatedTask);
    playEditSound();
    setShowEditModal(false);
  };

  // Archivar
  const handleArchive = async () => {
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}/archive`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.ok) {
        if (onArchive) onArchive(task.id);
        playArchiveSound();
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al archivar la tarea');
      }
    } catch (error) {
      console.error('Error al archivar la tarea:', error);
      setActionError('Error al archivar la tarea');
    }
  };

  // Desarchivar
  const handleUnarchive = async () => {
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}/unarchive`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${token}`,
        },
      });
      if (response.ok) {
        const updatedTask = await response.json();
        if (onUnarchive) onUnarchive(updatedTask.id);
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al desarchivar la tarea');
      }
    } catch (error) {
      console.error('Error al desarchivar la tarea:', error);
      setActionError('Error al desarchivar la tarea');
    }
  };

  // Cambiar status via dropdown
  const handleStatusChange = async (newStatus) => {
    if (!newStatus) {
      console.error('Nuevo estado no proporcionado.');
      return;
    }
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ status: newStatus }),
      });
      if (response.ok) {
        const updatedTask = await response.json();
        if (onEdit) onEdit(task.id, updatedTask);
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al cambiar el estado de la tarea');
      }
    } catch (error) {
      console.error('Error al cambiar el estado de la tarea:', error);
      setActionError('Error al cambiar el estado de la tarea');
    }
  };

  // Cambiar dificultad via dropdown
  const handleDifficultyChange = async (newDifficulty) => {
    if (!newDifficulty) {
      console.error('Nueva dificultad no proporcionada.');
      return;
    }
    setActionError('');
    try {
      const response = await fetch(`/api/tasks/${task.id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ difficulty: parseInt(newDifficulty, 10) }),
      });
      if (response.ok) {
        const updatedTask = await response.json();
        if (onEdit) onEdit(task.id, updatedTask);
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al cambiar la dificultad de la tarea');
      }
    } catch (error) {
      console.error('Error al cambiar la dificultad de la tarea:', error);
      setActionError('Error al cambiar la dificultad de la tarea');
    }
  };

  // Color para estado
  const getStatusColor = (status) => {
    switch (status) {
      case 'Pending':
        return '#007bff'; // Azul
      case 'In Progress':
        return '#ffc107'; // Amarillo
      case 'Completed':
        return '#28a745'; // Verde
      case 'Archived':
        return '#6c757d'; // Gris
      default:
        return '#6c757d';
    }
  };

  // Color para dificultad
  const getDifficultyColor = (difficulty) => {
    switch (difficulty) {
      case 1:
        return '#28a745'; // Verde
      case 2:
        return '#ffc107'; // Amarillo
      case 3:
        return '#dc3545'; // Rojo
      default:
        return '#6c757d';
    }
  };

  return (
    <>
      <div
        className={`task-item ${task.status === 'Completed' ? 'completed' : ''} ${
          task.status === 'Archived' ? 'archived' : ''
        }`}
      >
        {/* Dropdown men√∫ (3 puntos) */}
        <div className="dropdown-top-right">
          <Dropdown>
            <Dropdown.Toggle variant="secondary" id={`dropdown-${task.id}`}>
              <FaEllipsisV />
            </Dropdown.Toggle>
            <Dropdown.Menu>
              {task.status !== 'Archived' && (
                <>
                  <Dropdown.Item onClick={() => setShowEditModal(true)}>
                    <FaEdit /> Editar
                  </Dropdown.Item>
                  {task.status !== 'Completed' && (
                    <Dropdown.Item
                      onClick={handleComplete}
                      className="complete-dropdown-item"
                    >
                      <FaCheck /> Completar
                    </Dropdown.Item>
                  )}
                  {task.status === 'Completed' && (
                    <Dropdown.Item
                      onClick={handleContinue}
                      className="continue-dropdown-item"
                    >
                      <FaUndo /> Continuar
                    </Dropdown.Item>
                  )}
                  <Dropdown.Item
                    onClick={handleArchive}
                    className="archive-dropdown-item"
                  >
                    <FaArchive /> Archivar
                  </Dropdown.Item>
                </>
              )}

              {task.status === 'Archived' && (
                <Dropdown.Item
                  onClick={handleUnarchive}
                  className="unarchive-dropdown-item"
                >
                  <FaUndo /> Desarchivar
                </Dropdown.Item>
              )}

              <Dropdown.Divider />
              <Dropdown.Item
                onClick={handleDelete}
                className="delete-dropdown-item"
              >
                <FaTrashAlt /> Eliminar
              </Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </div>

        <h3>{task.name}</h3>
        <p>{task.description}</p>

        {/* Dropdowns de estado/dificultad s√≥lo si no est√° archivada */}
        {task.status !== 'Archived' && (
          <div className="status-difficulty">
            <Dropdown className="status-dropdown">
              <Dropdown.Toggle
                variant="light"
                className="status-toggle"
                style={{
                  backgroundColor: getStatusColor(task.status),
                  color: 'white',
                }}
              >
                {task.status}
              </Dropdown.Toggle>
              <Dropdown.Menu>
                <Dropdown.Item
                  onClick={() => handleStatusChange('Pending')}
                  className="status-pending"
                >
                  Pendiente
                </Dropdown.Item>
                <Dropdown.Item
                  onClick={() => handleStatusChange('In Progress')}
                  className="status-in-progress"
                >
                  En Progreso
                </Dropdown.Item>
                <Dropdown.Item
                  onClick={() => handleStatusChange('Completed')}
                  className="status-completed"
                >
                  Completado
                </Dropdown.Item>
              </Dropdown.Menu>
            </Dropdown>

            <Dropdown className="difficulty-dropdown">
              <Dropdown.Toggle
                variant="light"
                className="difficulty-toggle"
                style={{
                  backgroundColor: getDifficultyColor(task.difficulty),
                  color: 'white',
                }}
              >
                {task.difficulty === 1
                  ? 'F√°cil'
                  : task.difficulty === 2
                  ? 'Medio'
                  : 'Dif√≠cil'}
              </Dropdown.Toggle>
              <Dropdown.Menu>
                <Dropdown.Item
                  onClick={() => handleDifficultyChange(1)}
                  className="difficulty-1"
                >
                  1 - F√°cil
                </Dropdown.Item>
                <Dropdown.Item
                  onClick={() => handleDifficultyChange(2)}
                  className="difficulty-2"
                >
                  2 - Medio
                </Dropdown.Item>
                <Dropdown.Item
                  onClick={() => handleDifficultyChange(3)}
                  className="difficulty-3"
                >
                  3 - Dif√≠cil
                </Dropdown.Item>
              </Dropdown.Menu>
            </Dropdown>
          </div>
        )}

        <p>Fecha de Creaci√≥n: {new Date(task.created_at).toLocaleString()}</p>
        {task.estimated_time && <p>Tiempo Estimado: {task.estimated_time} horas</p>}
        {task.actual_time && <p>Tiempo Real: {task.actual_time} horas</p>}

        {/* Bot√≥n "Completar" aparte si no est√° completada/archivada */}
        {task.status !== 'Archived' && task.status !== 'Completed' && (
          <Button
            variant="success"
            className="complete-button"
            onClick={handleComplete}
            title="Completar Tarea"
          >
            <FaCheck /> Completar
          </Button>
        )}

        {/* Bot√≥n "Desarchivar" si est√° archivada */}
        {task.status === 'Archived' && (
          <Button
            variant="info"
            className="unarchive-button"
            onClick={handleUnarchive}
            title="Desarchivar Tarea"
          >
            <FaUndo /> Desarchivar
          </Button>
        )}

        {/* Mostramos errores */}
        {actionError && <Alert variant="danger">{actionError}</Alert>}
      </div>

      {/* Modal de edici√≥n */}
      <EditTaskModal
        show={showEditModal}
        handleClose={() => setShowEditModal(false)}
        task={task}
        handleSave={handleEditSave}
      />

      {/* Confirmaci√≥n para eliminar */}
      <ConfirmModal
        show={showDeleteConfirm}
        handleClose={() => setShowDeleteConfirm(false)}
        handleConfirm={confirmDelete}
        title="Confirmar Eliminaci√≥n"
        body="¬øEst√°s seguro de que deseas eliminar esta tarea? Esta acci√≥n no se puede deshacer."
      />
    </>
  );
}

export default TaskItem;

----- ./frontend/src/components/AdminPanel.js -----

----- ./frontend/src/components/TaskForm.js -----
// frontend/src/components/TaskForm.js
import React, { useState } from 'react';
import './TaskForm.css';
import useSound from '../hooks/useSound';
import addTaskSound from '../assets/sounds/notification-1-269296.mp3';
import { Form, Button } from 'react-bootstrap';
import { FaEdit, FaClock, FaCheckCircle, FaExclamationCircle } from 'react-icons/fa';
import authService from '../services/authService';

function TaskForm({ onTaskAdded }) {
  const [task, setTask] = useState({
    name: '',
    description: '',
    priority: 'Low',
    difficulty: 1,
    status: 'Pending',
    estimated_time: '',
  });
  const [message, setMessage] = useState('');
  const playAddSound = useSound(addTaskSound);

  const handleChange = (e) => {
    const { name, value } = e.target;
    let newValue = value;

    if (name === 'difficulty') {
      newValue = parseInt(value, 10);
    } else if (name === 'estimated_time') {
      newValue = value === '' ? '' : parseFloat(value);
    }
    setTask({ ...task, [name]: newValue });
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Tomamos el token del usuario logueado
    const user = authService.getCurrentUser();
    if (!user || !user.token) {
      setMessage('No hay usuario autenticado para crear tareas.');
      return;
    }

    try {
      const response = await fetch('/api/tasks', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          // Lo importante:
          'Authorization': `Bearer ${user.token}`,
        },
        body: JSON.stringify(task),
      });

      if (response.ok) {
        const newTask = await response.json();
        onTaskAdded(newTask);
        playAddSound();

        // Limpiar formulario y mostrar √©xito
        setTask({
          name: '',
          description: '',
          priority: 'Low',
          difficulty: 1,
          status: 'Pending',
          estimated_time: '',
        });
        setMessage('¬°Tarea agregada exitosamente!');

        setTimeout(() => setMessage(''), 5000); 
      } else {
        const errorData = await response.json();
        setMessage(errorData.error || 'Fallo al agregar la tarea.');
      }
    } catch (error) {
      console.error('Error al agregar tarea:', error);
      setMessage('Ocurri√≥ un error al agregar la tarea.');
    }
  };

  return (
    <Form className="task-form" onSubmit={handleSubmit}>
      <h2 className="form-title">
        <FaEdit /> Agregar Nueva Tarea
      </h2>
      
      {message && (
        <div className={`message ${message.includes('exitosamente') ? 'success' : 'error'}`}>
          {message}
        </div>
      )}

      {/* Campo Nombre */}
      <Form.Group>
        <Form.Label><FaEdit /> Nombre:</Form.Label>
        <Form.Control
          type="text"
          name="name"
          value={task.name}
          onChange={handleChange}
          required
          placeholder="Ingrese el nombre de la tarea"
        />
      </Form.Group>

      {/* Campo Descripci√≥n */}
      <Form.Group>
        <Form.Label><FaEdit /> Descripci√≥n:</Form.Label>
        <Form.Control
          as="textarea"
          name="description"
          value={task.description}
          onChange={handleChange}
          placeholder="Ingrese la descripci√≥n de la tarea"
        />
      </Form.Group>

      {/* Prioridad */}
      <Form.Group>
        <Form.Label><FaExclamationCircle /> Prioridad:</Form.Label>
        <Form.Control
          as="select"
          name="priority"
          value={task.priority}
          onChange={handleChange}
          className={`priority-dropdown priority-${task.priority.toLowerCase()}`}
        >
          <option value="Low">Baja</option>
          <option value="Medium">Media</option>
          <option value="High">Alta</option>
        </Form.Control>
      </Form.Group>

      {/* Dificultad */}
      <Form.Group>
        <Form.Label><FaExclamationCircle /> Dificultad:</Form.Label>
        <Form.Control
          as="select"
          name="difficulty"
          value={task.difficulty}
          onChange={handleChange}
          className={`difficulty-dropdown difficulty-${task.difficulty}`}
        >
          <option value={1}>1 - F√°cil</option>
          <option value={2}>2 - Medio</option>
          <option value={3}>3 - Dif√≠cil</option>
        </Form.Control>
      </Form.Group>

      {/* Estado */}
      <Form.Group>
        <Form.Label><FaCheckCircle /> Estado:</Form.Label>
        <Form.Control
          as="select"
          name="status"
          value={task.status}
          onChange={handleChange}
          className={`status-dropdown status-${task.status.toLowerCase().replace(' ', '-')}`}
        >
          <option value="Pending">Pendiente</option>
          <option value="In Progress">En Progreso</option>
          <option value="Completed">Completado</option>
        </Form.Control>
      </Form.Group>

      {/* Tiempo Estimado */}
      <Form.Group>
        <Form.Label><FaClock /> Tiempo Estimado (horas):</Form.Label>
        <Form.Control
          type="number"
          name="estimated_time"
          value={task.estimated_time}
          onChange={handleChange}
          min="0"
          step="0.5"
          placeholder="Horas estimadas"
        />
      </Form.Group>

      <Button type="submit" variant="success" className="add-task-button">
        Agregar Tarea
      </Button>
    </Form>
  );
}

export default TaskForm;

----- ./frontend/src/components/Header.js -----
// frontend/src/components/Header.js
import React, { useState } from 'react';
import authService from '../services/authService';
import { Navbar, Nav, Form } from 'react-bootstrap'; // Ejemplo usando react-bootstrap

const colorThemes = [
  { label: 'Claro', background: '#f8f9fa', text: '#000' },
  { label: 'Oscuro', background: '#343a40', text: '#fff' },
  { label: 'Azul', background: '#007bff', text: '#fff' },
  { label: 'Verde', background: '#28a745', text: '#fff' },
];

function Header() {
  const user = authService.getCurrentUser();

  // Estado para tema
  const [theme, setTheme] = useState(colorThemes[0]); // por defecto 'Claro'

  const handleThemeChange = (e) => {
    const index = e.target.value;
    setTheme(colorThemes[index]);
  };

  const headerStyle = {
    backgroundColor: theme.background,
    color: theme.text,
    transition: 'background-color 0.3s, color 0.3s',
  };

  return (
    <Navbar style={headerStyle} expand="lg">
      <Navbar.Brand style={{ color: theme.text }}>Mi App</Navbar.Brand>
      <Navbar.Toggle aria-controls="basic-navbar-nav" style={{ backgroundColor: theme.text }} />
      <Navbar.Collapse id="basic-navbar-nav">
        <Nav className="mr-auto">
          {user ? (
            <Nav.Item style={{ color: theme.text, marginRight: '1rem' }}>
              Bienvenido, {user.name}
            </Nav.Item>
          ) : (
            <Nav.Item style={{ color: theme.text, marginRight: '1rem' }}>
              No logueado
            </Nav.Item>
          )}
        </Nav>
        <Form inline>
          <Form.Control
            as="select"
            onChange={handleThemeChange}
            style={{ marginRight: '10px' }}
          >
            {colorThemes.map((ct, idx) => (
              <option value={idx} key={idx}>
                {ct.label}
              </option>
            ))}
          </Form.Control>
        </Form>
      </Navbar.Collapse>
    </Navbar>
  );
}

export default Header;

----- ./frontend/src/components/EditProfileModal.js -----
// frontend/src/components/EditProfileModal.js
import React, { useState, useEffect } from 'react';
import { Modal, Button, Form, Alert, Spinner } from 'react-bootstrap';
import './EditProfileModal.css';
import useSound from '../hooks/useSound';
import editProfileSound from '../assets/sounds/notification-1-269296.mp3';
import authService from '../services/authService';

function EditProfileModal({ show, handleClose, profile, handleSave }) {
  const [updatedProfile, setUpdatedProfile] = useState({
    name: '',
    bio: '',
    profile_picture_url: '',
  });
  const [imageFile, setImageFile] = useState(null);
  const [uploading, setUploading] = useState(false);
  const [uploadError, setUploadError] = useState('');
  const [formError, setFormError] = useState('');
  const [formSuccess, setFormSuccess] = useState('');

  // Sonido al editar
  const playEditProfileSound = useSound(editProfileSound);

  // Al abrir el modal, llenar estado con los datos actuales
  useEffect(() => {
    if (show) {
      setUpdatedProfile({
        name: profile.name || '',
        bio: profile.bio || '',
        profile_picture_url: profile.profile_picture_url || '',
      });
      setImageFile(null);
      setUploadError('');
      setFormError('');
      setFormSuccess('');
    }
  }, [profile, show]);

  // Cambios en inputs de texto
  const handleChange = (e) => {
    const { name, value } = e.target;
    setUpdatedProfile((prev) => ({ ...prev, [name]: value }));
  };

  // Al elegir un archivo
  const handleImageChange = (e) => {
    if (e.target.files && e.target.files[0]) {
      setImageFile(e.target.files[0]);
      // Aqu√≠ podr√≠amos mostrar un preview local con objectURL si queremos
      setUpdatedProfile((prev) => ({
        ...prev,
        profile_picture_url: URL.createObjectURL(e.target.files[0]),
      }));
    }
  };

  // Subir la imagen al backend
  const uploadImage = async () => {
    if (!imageFile) return null; // no se seleccion√≥ archivo nuevo

    const formData = new FormData();
    formData.append('profilePicture', imageFile);

    try {
      setUploading(true);
      const response = await fetch('/api/upload/profile-picture', {
        method: 'POST',
        body: formData,
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Error al subir la imagen');
      }
      const data = await response.json(); // { imageUrl: 'http://localhost:5000/uploads/...' }
      return data.imageUrl;
    } catch (error) {
      console.error('Error al subir la imagen:', error);
      setUploadError(error.message);
      return null;
    } finally {
      setUploading(false);
    }
  };

  // Guardar los cambios del perfil
  const onSave = async () => {
    setFormError('');
    setFormSuccess('');

    // Validaci√≥n b√°sica: nombre obligatorio
    if (!updatedProfile.name.trim()) {
      setFormError('El nombre es obligatorio.');
      return;
    }

    // Subir imagen si hay una nueva
    let finalImageUrl = updatedProfile.profile_picture_url;
    if (imageFile) {
      const uploadedUrl = await uploadImage();
      if (!uploadedUrl) {
        // Fall√≥ subida
        return;
      }
      finalImageUrl = uploadedUrl; // URL final devuelta por el backend
    }

    // Tomar token del usuario
    const user = authService.getCurrentUser();
    if (!user || !user.token) {
      setFormError('No hay usuario autenticado.');
      return;
    }

    try {
      // PUT /api/profile con Bearer Token
      const response = await fetch('/api/profile', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${user.token}`,
        },
        body: JSON.stringify({
          name: updatedProfile.name,
          bio: updatedProfile.bio,
          profile_picture_url: finalImageUrl,
        }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        setFormError(errorData.error || 'Error al actualizar el perfil');
        return;
      }

      const data = await response.json(); // Perfil actualizado
      // Llamamos a handleSave para actualizar el state en ProfilePage
      handleSave(data);
      playEditProfileSound();
      setFormSuccess('Perfil actualizado exitosamente.');

      // Cerrar modal un poco despu√©s
      setTimeout(() => {
        handleClose();
        setFormSuccess('');
      }, 1500);
    } catch (error) {
      console.error('Error al actualizar el perfil:', error);
      setFormError('Error al actualizar el perfil');
    }
  };

  return (
    <Modal
      show={show}
      onHide={() => {
        handleClose();
        setUploadError('');
        setFormError('');
        setFormSuccess('');
      }}
      centered
    >
      <Modal.Header closeButton>
        <Modal.Title>Editar Perfil</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        {formError && <Alert variant="danger">{formError}</Alert>}
        {formSuccess && <Alert variant="success">{formSuccess}</Alert>}
        {uploadError && <Alert variant="danger">{uploadError}</Alert>}

        <Form>
          <Form.Group controlId="formProfileName">
            <Form.Label>Nombre</Form.Label>
            <Form.Control
              type="text"
              name="name"
              value={updatedProfile.name}
              onChange={handleChange}
              placeholder="Ingrese su nombre"
              required
            />
          </Form.Group>

          <Form.Group controlId="formProfileBio" className="mt-3">
            <Form.Label>Biograf√≠a</Form.Label>
            <Form.Control
              as="textarea"
              rows={3}
              name="bio"
              value={updatedProfile.bio}
              onChange={handleChange}
              placeholder="Ingrese una breve biograf√≠a"
            />
          </Form.Group>

          <Form.Group controlId="formImageUpload" className="mt-3">
            <Form.Label>Imagen de Perfil</Form.Label>
            <Form.Control
              type="file"
              accept="image/*"
              onChange={handleImageChange}
            />
            {updatedProfile.profile_picture_url && (
              <div className="mt-3">
                {/* Preview local o imagen actual */}
                <img
                  src={updatedProfile.profile_picture_url}
                  alt="Preview"
                  className="img-preview"
                />
              </div>
            )}
          </Form.Group>
        </Form>
      </Modal.Body>
      <Modal.Footer>
        <Button
          variant="secondary"
          onClick={() => {
            handleClose();
            setUploadError('');
            setFormError('');
            setFormSuccess('');
          }}
        >
          Cancelar
        </Button>
        <Button variant="primary" onClick={onSave} disabled={uploading}>
          {uploading ? (
            <>
              <Spinner
                as="span"
                animation="border"
                size="sm"
                role="status"
                aria-hidden="true"
              />{' '}
              Guardando...
            </>
          ) : (
            'Guardar Cambios'
          )}
        </Button>
      </Modal.Footer>
    </Modal>
  );
}

export default EditProfileModal;

----- ./frontend/src/components/LoginForm.js -----
// frontend/src/components/LoginForm.js
import React, { useState } from 'react';
import { Form, Button } from 'react-bootstrap';
import './LoginForm.css'; // Aseg√∫rate de tener este archivo CSS

function LoginForm({ onLogin }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    onLogin({ email, password });
  };

  return (
    <Form onSubmit={handleSubmit} className="login-form">
      <Form.Group controlId="formBasicEmail">
        <Form.Label>Email</Form.Label>
        <Form.Control
          type="email"
          placeholder="Ingrese su email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
      </Form.Group>

      <Form.Group controlId="formBasicPassword">
        <Form.Label>Contrase√±a</Form.Label>
        <Form.Control
          type="password"
          placeholder="Ingrese su contrase√±a"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
      </Form.Group>

      <Button variant="primary" type="submit">
        Iniciar Sesi√≥n
      </Button>
    </Form>
  );
}

export default LoginForm;
----- ./frontend/src/components/ConfirmModal.js -----
// frontend/src/components/ConfirmModal.js
import React from 'react';
import { Modal, Button } from 'react-bootstrap';
import './ConfirmModal.css';

function ConfirmModal({ show, handleClose, handleConfirm, title, body }) {
  return (
    <Modal show={show} onHide={handleClose} centered>
      <Modal.Header closeButton>
        <Modal.Title>{title || 'Confirmaci√≥n'}</Modal.Title>
      </Modal.Header>
      <Modal.Body>
        <p>{body || '¬øEst√°s seguro?'}</p>
      </Modal.Body>
      <Modal.Footer>
        <Button variant="secondary" onClick={handleClose}>
          Cancelar
        </Button>
        <Button variant="danger" onClick={handleConfirm}>
          Confirmar
        </Button>
      </Modal.Footer>
    </Modal>
  );
}

export default ConfirmModal;

----- ./frontend/src/components/TaskList.js -----
// frontend/src/components/TaskList.js
import React, { useState, useEffect } from 'react';
import TaskItem from './TaskItem';
import './TaskList.css';
import { Form, Row, Col, Button } from 'react-bootstrap';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { FaFilter, FaTimes } from 'react-icons/fa';

function TaskList({ tasks, setTasks }) {
  const [filters, setFilters] = useState({
    priority: [],
    difficulty: [],
    status: [],
  });
  const [filteredTasks, setFilteredTasks] = useState(tasks);
  const [showFilters, setShowFilters] = useState(false);

  useEffect(() => {
    applyFilters();
    // eslint-disable-next-line
  }, [tasks, filters]);

  const handleFilterChange = (category, value) => {
    setFilters((prevFilters) => {
      const alreadySelected = prevFilters[category].includes(value);
      const newCategory = alreadySelected
        ? prevFilters[category].filter((item) => item !== value)
        : [...prevFilters[category], value];
      return { ...prevFilters, [category]: newCategory };
    });
  };

  const applyFilters = () => {
    let filtered = [...tasks];
    // Filtro Prioridad
    if (filters.priority.length > 0) {
      filtered = filtered.filter((task) => filters.priority.includes(task.priority));
    }
    // Filtro Dificultad
    if (filters.difficulty.length > 0) {
      filtered = filtered.filter((task) =>
        filters.difficulty.includes(task.difficulty.toString())
      );
    }
    // Filtro Estado
    if (filters.status.length > 0) {
      filtered = filtered.filter((task) => filters.status.includes(task.status));
    }
    setFilteredTasks(filtered);
  };

  const handleClearFilters = () => {
    setFilters({
      priority: [],
      difficulty: [],
      status: [],
    });
  };

  // L√≥gica drag & drop
  const handleOnDragEnd = (result) => {
    if (!result.destination) return;
    const items = Array.from(filteredTasks);
    const [reorderedItem] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);
    setFilteredTasks(items);
    // Opcional: Actualizar orden en el backend si es necesario
  };

  return (
    <div className="task-list">
      {/* Bot√≥n para Filtros */}
      <Button
        variant="outline-primary"
        className="filter-toggle"
        onClick={() => setShowFilters(!showFilters)}
      >
        {showFilters ? <FaTimes /> : <FaFilter />}{' '}
        {showFilters ? 'Ocultar Filtros' : 'Mostrar Filtros'}
      </Button>

      {showFilters && (
        <div className="filters">
          <Form>
            <Row>
              <Col md={4} sm={12}>
                <Form.Group>
                  <Form.Label><FaFilter /> Prioridad</Form.Label>
                  <Form.Check
                    type="checkbox"
                    label="Baja"
                    value="Low"
                    checked={filters.priority.includes('Low')}
                    onChange={() => handleFilterChange('priority', 'Low')}
                  />
                  <Form.Check
                    type="checkbox"
                    label="Media"
                    value="Medium"
                    checked={filters.priority.includes('Medium')}
                    onChange={() => handleFilterChange('priority', 'Medium')}
                  />
                  <Form.Check
                    type="checkbox"
                    label="Alta"
                    value="High"
                    checked={filters.priority.includes('High')}
                    onChange={() => handleFilterChange('priority', 'High')}
                  />
                </Form.Group>
              </Col>
              <Col md={4} sm={12}>
                <Form.Group>
                  <Form.Label><FaFilter /> Dificultad</Form.Label>
                  <Form.Check
                    type="checkbox"
                    label="1 - F√°cil"
                    value="1"
                    checked={filters.difficulty.includes('1')}
                    onChange={() => handleFilterChange('difficulty', '1')}
                  />
                  <Form.Check
                    type="checkbox"
                    label="2 - Medio"
                    value="2"
                    checked={filters.difficulty.includes('2')}
                    onChange={() => handleFilterChange('difficulty', '2')}
                  />
                  <Form.Check
                    type="checkbox"
                    label="3 - Dif√≠cil"
                    value="3"
                    checked={filters.difficulty.includes('3')}
                    onChange={() => handleFilterChange('difficulty', '3')}
                  />
                </Form.Group>
              </Col>
              <Col md={4} sm={12}>
                <Form.Group>
                  <Form.Label><FaFilter /> Estado</Form.Label>
                  <Form.Check
                    type="checkbox"
                    label="Pendiente"
                    value="Pending"
                    checked={filters.status.includes('Pending')}
                    onChange={() => handleFilterChange('status', 'Pending')}
                  />
                  <Form.Check
                    type="checkbox"
                    label="En Progreso"
                    value="In Progress"
                    checked={filters.status.includes('In Progress')}
                    onChange={() => handleFilterChange('status', 'In Progress')}
                  />
                  <Form.Check
                    type="checkbox"
                    label="Completado"
                    value="Completed"
                    checked={filters.status.includes('Completed')}
                    onChange={() => handleFilterChange('status', 'Completed')}
                  />
                </Form.Group>
              </Col>
            </Row>
            <Button variant="secondary" onClick={handleClearFilters} className="mt-3">
              Limpiar Filtros
            </Button>
          </Form>
        </div>
      )}

      <DragDropContext onDragEnd={handleOnDragEnd}>
        <Droppable droppableId="tasks">
          {(provided) => (
            <div className="task-container" {...provided.droppableProps} ref={provided.innerRef}>
              {filteredTasks.length > 0 ? (
                filteredTasks.map((task, index) => (
                  <Draggable key={task.id} draggableId={task.id.toString()} index={index}>
                    {(provided, snapshot) => (
                      <div
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                        className={snapshot.isDragging ? 'dragging' : ''}
                      >
                        <TaskItem
                          task={task}
                          onComplete={(id) =>
                            setTasks((prev) =>
                              prev.map((t) =>
                                t.id === id ? { ...t, status: 'Completed' } : t
                              )
                            )
                          }
                          onDelete={(id) =>
                            setTasks((prev) => prev.filter((t) => t.id !== id))
                          }
                          onEdit={(id, updatedTask) =>
                            setTasks((prev) =>
                              prev.map((t) => (t.id === id ? updatedTask : t))
                            )
                          }
                          onArchive={(id) =>
                            setTasks((prev) => prev.filter((t) => t.id !== id))
                          }
                          onUnarchive={(id) =>
                            setTasks((prev) => [...prev, { ...task, status: 'Pending' }])
                          }
                        />
                      </div>
                    )}
                  </Draggable>
                ))
              ) : (
                <p>No hay tareas que coincidan con los filtros seleccionados.</p>
              )}
              {provided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>
    </div>
  );
}

export default TaskList;

----- ./frontend/src/components/UserItem.js -----

----- ./frontend/src/hooks/useSound.js -----
// frontend/src/hooks/useSound.js
import { useCallback } from 'react';

const useSound = (url) => {
  const play = useCallback(() => {
    const audio = new Audio(url);
    audio.play().catch((error) => {
      console.error('Error al reproducir el sonido:', error);
    });
  }, [url]);

  return play;
};

export default useSound;

----- ./frontend/src/pages/AdminPage.js -----
// frontend/src/pages/AdminPage.js
import React from 'react';

function AdminPage() {
  return (
    <div>
      <h1>Panel de Administraci√≥n</h1>
      {/* Aqu√≠ puedes agregar el contenido del panel de administraci√≥n */}
    </div>
  );
}

export default AdminPage;
----- ./frontend/src/pages/LoginPage.js -----
// frontend/src/pages/LoginPage.js
import React, { useState } from 'react';
import LoginForm from '../components/LoginForm';
import authService from '../services/authService'; 
import { useNavigate } from 'react-router-dom';
import { Alert } from 'react-bootstrap';

function LoginPage({ onLogin }) {
  const [error, setError] = useState(null);
  const navigate = useNavigate();

  const handleLogin = async (credentials) => {
    try {
      const user = await authService.login(credentials);
      if (user) {
        onLogin(user); 
        setError(null);
        navigate('/'); // Redirige a la p√°gina principal o a donde desees
      }
    } catch (error) {
      // Manejar errores espec√≠ficos si el backend env√≠a mensajes
      setError(error.response?.data?.msg || error.message);
    }
  };

  return (
    <div>
      <h1>Iniciar Sesi√≥n</h1>
      {error && <Alert variant="danger">{error}</Alert>}
      <LoginForm onLogin={handleLogin} />
    </div>
  );
}

export default LoginPage;

----- ./frontend/src/pages/ArchivedTasksPage.js -----
// frontend/src/pages/ArchivedTasksPage.js
import React, { useState, useEffect } from 'react';
import TaskItem from '../components/TaskItem';
import ConfirmModal from '../components/ConfirmModal';
import './ArchivedTasksPage.css';
import { DragDropContext, Droppable, Draggable } from 'react-beautiful-dnd';
import { Alert } from 'react-bootstrap';
import authService from '../services/authService';

function ArchivedTasksPage() {
  const [archivedTasks, setArchivedTasks] = useState([]);
  const [error, setError] = useState(null);
  const [actionError, setActionError] = useState('');

  // Eliminar
  const [taskToDelete, setTaskToDelete] = useState(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);

  const fetchArchivedTasks = async () => {
    try {
      const user = authService.getCurrentUser();
      if (!user) {
        setError('No hay usuario autenticado');
        return;
      }
      const response = await fetch('/api/tasks/archived', {
        headers: { Authorization: `Bearer ${user.token}` },
      });
      if (!response.ok) {
        throw new Error('Error al obtener las tareas archivadas');
      }
      const data = await response.json();
      setArchivedTasks(data);
    } catch (err) {
      console.error('Error al obtener tareas archivadas:', err);
      setError('Error al obtener tareas archivadas');
    }
  };

  useEffect(() => {
    fetchArchivedTasks();
  }, []);

  // Desarchivar
  const handleUnarchive = async (id) => {
    setActionError('');
    try {
      const user = authService.getCurrentUser();
      const response = await fetch(`/api/tasks/${id}/unarchive`, {
        method: 'PUT',
        headers: {
          Authorization: `Bearer ${user.token}`,
        },
      });
      if (response.ok) {
        // Quitar la tarea del array
        setArchivedTasks((prev) => prev.filter((t) => t.id !== id));
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al desarchivar la tarea');
      }
    } catch (error) {
      console.error('Error al desarchivar la tarea:', error);
      setActionError('Error al desarchivar la tarea');
    }
  };

  // Editar Tarea archivada
  const handleEdit = async (id, updatedTask) => {
    setActionError('');
    try {
      const user = authService.getCurrentUser();
      const response = await fetch(`/api/tasks/${id}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${user.token}`,
        },
        body: JSON.stringify(updatedTask),
      });
      if (response.ok) {
        const data = await response.json();
        setArchivedTasks((prev) => prev.map((t) => (t.id === id ? data : t)));
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al editar la tarea archivada');
      }
    } catch (error) {
      console.error('Error al editar la tarea archivada:', error);
      setActionError('Error al editar la tarea archivada');
    }
  };

  // Eliminar Tarea archivada
  const handleDelete = (task) => {
    setTaskToDelete(task);
    setShowDeleteConfirm(true);
  };

  const confirmDelete = async () => {
    setActionError('');
    try {
      const user = authService.getCurrentUser();
      const response = await fetch(`/api/tasks/${taskToDelete.id}`, {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${user.token}` },
      });
      if (response.ok) {
        setArchivedTasks((prev) => prev.filter((t) => t.id !== taskToDelete.id));
        setShowDeleteConfirm(false);
        setTaskToDelete(null);
      } else {
        const errorData = await response.json();
        setActionError(errorData.error || 'Error al eliminar la tarea archivada');
      }
    } catch (error) {
      console.error('Error al eliminar la tarea archivada:', error);
      setActionError('Error al eliminar la tarea archivada');
    }
  };

  const handleDeleteCancel = () => {
    setShowDeleteConfirm(false);
    setTaskToDelete(null);
  };

  // Drag & Drop archivadas
  const handleOnDragEnd = (result) => {
    if (!result.destination) return;
    const items = Array.from(archivedTasks);
    const [reorderedItem] = items.splice(result.source.index, 1);
    items.splice(result.destination.index, 0, reorderedItem);
    setArchivedTasks(items);
    // Opcional: actualizar orden en backend
  };

  return (
    <div className="archived-tasks-page">
      <h2>Tareas Archivadas</h2>
      {error && <Alert variant="danger">{error}</Alert>}
      {actionError && <Alert variant="danger">{actionError}</Alert>}

      <DragDropContext onDragEnd={handleOnDragEnd}>
        <Droppable droppableId="archivedTasks">
          {(provided) => (
            <div
              className="task-container"
              {...provided.droppableProps}
              ref={provided.innerRef}
            >
              {archivedTasks.length > 0 ? (
                archivedTasks.map((task, index) => (
                  <Draggable
                    key={task.id}
                    draggableId={task.id.toString()}
                    index={index}
                  >
                    {(provided, snapshot) => (
                      <div
                        ref={provided.innerRef}
                        {...provided.draggableProps}
                        {...provided.dragHandleProps}
                        className={snapshot.isDragging ? 'dragging' : ''}
                      >
                        <TaskItem
                          task={task}
                          onUnarchive={handleUnarchive}
                          onEdit={handleEdit}
                          onDelete={handleDelete}
                        />
                      </div>
                    )}
                  </Draggable>
                ))
              ) : (
                <p>No hay tareas archivadas.</p>
              )}
              {provided.placeholder}
            </div>
          )}
        </Droppable>
      </DragDropContext>

      {taskToDelete && (
        <ConfirmModal
          show={showDeleteConfirm}
          handleClose={handleDeleteCancel}
          handleConfirm={confirmDelete}
          title="Confirmar Eliminaci√≥n"
          body="¬øEst√°s seguro de que deseas eliminar esta tarea archivada? Esta acci√≥n no se puede deshacer."
        />
      )}
    </div>
  );
}

export default ArchivedTasksPage;

----- ./frontend/src/pages/TaskMetricsPage.js -----
// frontend/src/pages/TaskMetricsPage.js
import React, { useState, useEffect } from 'react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  Legend,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  ResponsiveContainer,
} from 'recharts';
import { Alert } from 'react-bootstrap';
import authService from '../services/authService'; // Para enviar el token

function TaskMetricsPage() {
  const [stats, setStats] = useState({
    totalTasks: 0,
    completed: 0,
    pending: 0,
    inProgress: 0,
    stackedData: [], // priority/difficulty
  });
  const [error, setError] = useState(null);

  const pieColors = ['#28a745', '#ffc107', '#007bff'];
  const difficultyColors = ['#6f42c1', '#20c997', '#fd7e14', '#dc3545', '#17a2b8'];

  useEffect(() => {
    const fetchStats = async () => {
      try {
        // Obtener user/token
        const user = authService.getCurrentUser();
        if (!user || !user.token) {
          throw new Error('No hay usuario logueado o token no disponible');
        }

        // Llamar al backend con Bearer token
        const response = await fetch('/api/tasks/stats', {
          headers: {
            Authorization: `Bearer ${user.token}`,
          },
        });
        if (!response.ok) {
          throw new Error('Error al obtener estad√≠sticas');
        }
        const data = await response.json();
        setStats(data);
      } catch (err) {
        console.error('Error al obtener estad√≠sticas:', err);
        setError('Error al obtener estad√≠sticas');
      }
    };
    fetchStats();
  }, []);

  // Pie chart
  const pieData = [
    { name: 'Completadas', value: stats.completed },
    { name: 'Pendientes', value: stats.pending },
    { name: 'En Progreso', value: stats.inProgress },
  ];

  // Evitar error forEach => fallback a []
  const safeStackedData = stats.stackedData || [];

  // Analizar keys difficulty_1, difficulty_2, ...
  const allKeys = new Set();
  safeStackedData.forEach((item) => {
    Object.keys(item).forEach((k) => {
      if (k.startsWith('difficulty_')) {
        allKeys.add(k);
      }
    });
  });
  const difficultyKeys = Array.from(allKeys).sort();

  return (
    <div className="container my-4">
      <h2 className="text-center">Task Metrics Dashboard</h2>
      {error && <Alert variant="danger">{error}</Alert>}

      <div className="row">
        {/* Pie chart */}
        <div className="col-md-6">
          <h4 className="text-center">Estado de Tareas</h4>
          <ResponsiveContainer width="100%" height={300}>
            <PieChart>
              <Pie
                data={pieData}
                dataKey="value"
                nameKey="name"
                cx="50%"
                cy="50%"
                outerRadius={90}
                label
              >
                {pieData.map((entry, index) => (
                  <Cell
                    key={`cell-${index}`}
                    fill={pieColors[index % pieColors.length]}
                  />
                ))}
              </Pie>
              <Tooltip />
              <Legend />
            </PieChart>
          </ResponsiveContainer>
        </div>

        {/* Stacked Bar Chart */}
        <div className="col-md-6">
          <h4 className="text-center">Prioridad (Barras apiladas por Dificultad)</h4>
          <ResponsiveContainer width="100%" height={300}>
            <BarChart
              data={safeStackedData}
              margin={{ top: 20, right: 30, left: 0, bottom: 5 }}
            >
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="priority" />
              <YAxis allowDecimals={false} />
              <Tooltip />
              <Legend />
              {difficultyKeys.map((diffKey, idx) => (
                <Bar
                  key={diffKey}
                  dataKey={diffKey}
                  stackId="stack"
                  fill={difficultyColors[idx % difficultyColors.length]}
                  name={diffKey}
                />
              ))}
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>

      <div className="mt-4 p-3 bg-light">
        <p><strong>Total de Tareas:</strong> {stats.totalTasks}</p>
        <p><strong>Completadas:</strong> {stats.completed}</p>
        <p><strong>Pendientes:</strong> {stats.pending}</p>
        <p><strong>En Progreso:</strong> {stats.inProgress}</p>
      </div>
    </div>
  );
}

export default TaskMetricsPage;

----- ./frontend/src/pages/FriendsPage.js -----
// frontend/src/pages/FriendsPage.js
import React, { useState, useEffect } from 'react';
import authService from '../services/authService';
import useSound from '../hooks/useSound';
import { Alert, Button, Form, Card, Row, Col } from 'react-bootstrap';

// Sonidos
import friendRequestSound from '../assets/sounds/intro-sound-4-270301.mp3';
import acceptSound from '../assets/sounds/level-up-191997.mp3';
import errorSound from '../assets/sounds/ui-sound-off-270300.mp3';

function FriendsPage() {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [friends, setFriends] = useState([]);
  const [requests, setRequests] = useState([]);
  const [error, setError] = useState('');

  const playRequestSound = useSound(friendRequestSound);
  const playAcceptSound = useSound(acceptSound);
  const playErrorSound = useSound(errorSound);

  const user = authService.getCurrentUser();

  const fetchFriends = async () => {
    try {
      const res = await fetch('/api/friends/list', {
        headers: {
          Authorization: `Bearer ${user?.token}`,
        },
      });
      if (res.ok) {
        const data = await res.json();
        setFriends(data);
      } else {
        playErrorSound();
        setError('Error al obtener amigos');
      }
    } catch (err) {
      playErrorSound();
      setError('Error al obtener amigos');
    }
  };

  const fetchRequests = async () => {
    try {
      const res = await fetch('/api/friends/requests', {
        headers: {
          Authorization: `Bearer ${user?.token}`,
        },
      });
      if (res.ok) {
        const data = await res.json();
        setRequests(data);
      } else {
        playErrorSound();
        setError('Error al obtener solicitudes');
      }
    } catch (err) {
      playErrorSound();
      setError('Error al obtener solicitudes');
    }
  };

  useEffect(() => {
    fetchFriends();
    fetchRequests();
    // eslint-disable-next-line
  }, []);

  const handleSearch = async (e) => {
    e.preventDefault();
    setError('');
    try {
      const res = await fetch(`/api/friends/search?query=${searchQuery}`, {
        headers: {
          Authorization: `Bearer ${user?.token}`,
        },
      });
      if (res.ok) {
        const data = await res.json();
        setSearchResults(data);
      } else {
        playErrorSound();
        setError('Error al buscar usuarios');
      }
    } catch (err) {
      playErrorSound();
      setError('Error al buscar usuarios');
    }
  };

  const handleSendRequest = async (to_user_id) => {
    setError('');
    try {
      const res = await fetch('/api/friends/send', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${user?.token}`,
        },
        body: JSON.stringify({ to_user_id }),
      });
      if (res.ok) {
        playRequestSound();
        alert(`Solicitud de amistad enviada a user_id=${to_user_id}`);
      } else {
        const errorData = await res.json();
        playErrorSound();
        setError(errorData.error || 'Error al enviar solicitud');
      }
    } catch (err) {
      playErrorSound();
      setError('Error al enviar solicitud');
    }
  };

  const handleAccept = async (requestId) => {
    setError('');
    try {
      const res = await fetch(`/api/friends/${requestId}/accept`, {
        method: 'PUT',
        headers: { Authorization: `Bearer ${user?.token}` },
      });
      if (res.ok) {
        // Eliminar la request de la lista
        setRequests((prev) => prev.filter((r) => r.id !== requestId));
        fetchFriends();
        playAcceptSound();
      } else {
        playErrorSound();
        setError('Error al aceptar solicitud');
      }
    } catch (err) {
      playErrorSound();
      setError('Error al aceptar solicitud');
    }
  };

  const handleReject = async (requestId) => {
    setError('');
    try {
      const res = await fetch(`/api/friends/${requestId}/reject`, {
        method: 'PUT',
        headers: { Authorization: `Bearer ${user?.token}` },
      });
      if (res.ok) {
        // Quitar la request
        setRequests((prev) => prev.filter((r) => r.id !== requestId));
      } else {
        playErrorSound();
        setError('Error al rechazar solicitud');
      }
    } catch (err) {
      playErrorSound();
      setError('Error al rechazar solicitud');
    }
  };

  /**
   * Si la foto del usuario (req.from_photo, etc.) est√° vac√≠a,
   * usamos /default_silueta.jpeg como fallback.
   */
  const getPhotoOrDefault = (url) => {
    if (url && url.trim() !== '') {
      return url;
    }
    return '/default_silueta.jpeg'; // <-- Ajuste principal
  };

  return (
    <div className="container my-4">
      <h2>Amigos & Solicitudes</h2>
      {error && <Alert variant="danger">{error}</Alert>}

      {/* Secci√≥n de b√∫squeda */}
      <Form onSubmit={handleSearch} className="mb-4">
        <Form.Group>
          <Form.Label>Buscar usuario por email o ID</Form.Label>
          <Form.Control
            type="text"
            placeholder="user@example.com o 123"
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
          />
        </Form.Group>
        <Button variant="primary" type="submit" className="mt-2">
          Buscar
        </Button>
      </Form>

      {/* Resultados de b√∫squeda */}
      {searchResults.length > 0 && (
        <div className="mb-4">
          <h4>Resultados de la b√∫squeda:</h4>
          <Row>
            {searchResults.map((u) => (
              <Col key={u.id} xs={12} md={6} lg={4} className="mb-3">
                <Card>
                  <Card.Body className="d-flex align-items-center">
                    <img
                      src={getPhotoOrDefault(u.profile_picture_url)}
                      alt="avatar"
                      style={{
                        width: 50,
                        height: 50,
                        borderRadius: '50%',
                        marginRight: 10,
                      }}
                    />
                    <div>
                      <div>
                        <strong>ID:</strong> {u.id}
                      </div>
                      <div>
                        <strong>{u.name}</strong> <small>({u.email})</small>
                      </div>
                    </div>
                    <Button
                      variant="info"
                      size="sm"
                      onClick={() => handleSendRequest(u.id)}
                      className="ml-auto"
                    >
                      Enviar Solicitud
                    </Button>
                  </Card.Body>
                </Card>
              </Col>
            ))}
          </Row>
        </div>
      )}

      {/* Solicitudes pendientes */}
      <div className="mb-4">
        <h4>Solicitudes Recibidas</h4>
        {requests.length === 0 ? (
          <p>No tienes solicitudes pendientes.</p>
        ) : (
          <Row>
            {requests.map((req) => (
              <Col key={req.id} xs={12} md={6} lg={4} className="mb-3">
                <Card>
                  <Card.Body className="d-flex align-items-center">
                    <img
                      src={getPhotoOrDefault(req.from_photo)}
                      alt="avatar"
                      style={{
                        width: 50,
                        height: 50,
                        borderRadius: '50%',
                        marginRight: 10,
                      }}
                    />
                    <div>
                      <div>
                        <strong>De:</strong> {req.from_name} (ID: {req.from_user_id})
                      </div>
                    </div>
                    <div className="ml-auto">
                      <Button
                        variant="success"
                        size="sm"
                        onClick={() => handleAccept(req.id)}
                        style={{ marginRight: '5px' }}
                      >
                        Aceptar
                      </Button>
                      <Button
                        variant="danger"
                        size="sm"
                        onClick={() => handleReject(req.id)}
                      >
                        Rechazar
                      </Button>
                    </div>
                  </Card.Body>
                </Card>
              </Col>
            ))}
          </Row>
        )}
      </div>

      {/* Amigos aceptados */}
      <div>
        <h4>Mis Amigos</h4>
        {friends.length === 0 ? (
          <p>A√∫n no tienes amigos aceptados.</p>
        ) : (
          <Row>
            {friends.map((f) => {
              const isFromMe = f.from_user_id === user?.id;
              const friendId = isFromMe ? f.to_user_id : f.from_user_id;
              const friendName = isFromMe ? f.to_name : f.from_name;
              const friendPhoto = isFromMe ? f.to_photo : f.from_photo;

              return (
                <Col key={f.id} xs={12} md={6} lg={4} className="mb-3">
                  <Card>
                    <Card.Body className="d-flex align-items-center">
                      <img
                        src={getPhotoOrDefault(friendPhoto)}
                        alt="avatar"
                        style={{
                          width: 50,
                          height: 50,
                          borderRadius: '50%',
                          marginRight: 10,
                        }}
                      />
                      <div>
                        <div>
                          <strong>ID:</strong> {friendId}
                        </div>
                        <div>
                          <strong>{friendName}</strong> (status: {f.status})
                        </div>
                      </div>
                    </Card.Body>
                  </Card>
                </Col>
              );
            })}
          </Row>
        )}
      </div>
    </div>
  );
}

export default FriendsPage;

----- ./frontend/src/pages/HomePage.js -----
// frontend/src/pages/HomePage.js
import React, { useEffect, useState } from 'react';
import authService from '../services/authService';

function HomePage() {
  const [profile, setProfile] = useState(null);

  useEffect(() => {
    const user = authService.getCurrentUser();
    if (!user) return;
    fetch('/api/profile', {
      headers: {
        Authorization: `Bearer ${user.token}`,
      },
    })
      .then((res) => res.json())
      .then((data) => setProfile(data))
      .catch((err) => console.error(err));
  }, []);

  return (
    <div>
      <h1>Bienvenido a Planner2025</h1>
      <p>P√°gina principal de la aplicaci√≥n.</p>
      {profile?.profile_picture_url && (
        <img
          src={profile.profile_picture_url}
          alt="Mi Foto"
          style={{ width: '100px', height: '100px', borderRadius: '50%' }}
        />
      )}
    </div>
  );
}

export default HomePage;

----- ./frontend/src/pages/TaskPage.js -----
// --- frontend/src/pages/TaskPage.js ---
import React, { useState, useEffect } from 'react';
import TaskForm from '../components/TaskForm';
import TaskList from '../components/TaskList';
import './TaskPage.css';
import { Alert } from 'react-bootstrap';
import authService from '../services/authService';

function TaskPage() {
  const [tasks, setTasks] = useState([]);
  const [error, setError] = useState(null);
  const [message, setMessage] = useState('');

  const fetchTasks = async () => {
    try {
      const user = authService.getCurrentUser();
      if (!user) {
        setError('No hay usuario autenticado');
        return;
      }
      // Llamada al backend con Bearer Token
      const response = await fetch('/api/tasks', {
        headers: { 'Authorization': `Bearer ${user.token}` },
      });
      if (!response.ok) {
        throw new Error('Error al obtener las tareas');
      }
      const data = await response.json();
      setTasks(data);
    } catch (err) {
      console.error('Error al obtener las tareas:', err);
      setError('Error al obtener las tareas');
    }
  };

  useEffect(() => {
    fetchTasks();
  }, []);

  return (
    <div className="task-page">
      <h2>Gestor de Tareas</h2>
      {error && <Alert variant="danger">{error}</Alert>}
      {message && <Alert variant="success">{message}</Alert>}

      <div className="task-layout">
        <div className="task-form-column">
          {/* onTaskAdded actualiza estado global de tasks */}
          <TaskForm
            onTaskAdded={(newTask) => {
              setTasks((prev) => [newTask, ...prev]);
              setMessage('¬°Tarea agregada exitosamente!');
              setTimeout(() => setMessage(''), 3000);
            }}
          />
        </div>
        <div className="task-list-column">
          <TaskList tasks={tasks} setTasks={setTasks} />
        </div>
      </div>
    </div>
  );
}

export default TaskPage;

----- ./frontend/src/pages/ProfilePage.js -----
// frontend/src/pages/ProfilePage.js
import React, { useState, useEffect } from 'react';
import './ProfilePage.css';
import EditProfileModal from '../components/EditProfileModal';
import useSound from '../hooks/useSound';
import editProfileSound from '../assets/sounds/intro-sound-1-269293.mp3';
import { Alert } from 'react-bootstrap';
import authService from '../services/authService';

function ProfilePage() {
  const [profile, setProfile] = useState({
    name: '',
    email: '',
    bio: '',
    profile_picture_url: '',
  });
  const [showEditModal, setShowEditModal] = useState(false);
  const [error, setError] = useState(null);

  const playEditProfileSound = useSound(editProfileSound);

  // Al montar, obtenemos el perfil del backend
  useEffect(() => {
    const fetchProfile = async () => {
      try {
        const user = authService.getCurrentUser();
        if (!user || !user.token) {
          setError('No hay usuario logueado.');
          return;
        }
        const response = await fetch('/api/profile', {
          headers: {
            Authorization: `Bearer ${user.token}`,
          },
        });
        if (!response.ok) {
          throw new Error('Error al obtener el perfil');
        }
        const data = await response.json();
        setProfile(data);
      } catch (err) {
        console.error('Error al obtener el perfil:', err);
        setError('Error al obtener el perfil');
      }
    };

    fetchProfile();
  }, []);

  // Cuando el modal guarde, actualizamos el state local con la info
  const handleSaveProfile = (updatedProfile) => {
    setProfile(updatedProfile); // Actualiza la foto, name, bio
    playEditProfileSound();
  };

  // Fallback si la URL est√° vac√≠a
  const displayImage = profile.profile_picture_url?.trim()
    ? profile.profile_picture_url
    : '/default_silueta.jpeg';

  return (
    <div className="profile-layout">
      <aside className="profile-sidebar">
        <div className="profile-picture-container">
          <img
            src={displayImage}
            alt="Profile"
            className="profile-picture"
            onClick={() => setShowEditModal(true)}
            title="Editar Perfil"
          />
        </div>
        <h3>{profile.name}</h3>
        <p>{profile.bio}</p>
        <p>{profile.email}</p>

        <button
          className="btn btn-info mt-3"
          onClick={() => setShowEditModal(true)}
        >
          Editar Perfil
        </button>
      </aside>

      <div className="profile-content">
        {error && <Alert variant="danger">{error}</Alert>}
        {/* Aqu√≠ podr√≠as mostrar tareas del user, etc. */}
      </div>

      {/* Modal para editar */}
      <EditProfileModal
        show={showEditModal}
        handleClose={() => setShowEditModal(false)}
        profile={profile}
        handleSave={handleSaveProfile}
      />
    </div>
  );
}

export default ProfilePage;

----- ./frontend/src/pages/RegisterPage.js -----
// frontend/src/pages/RegisterPage.js
import React, { useState } from 'react';
import RegisterForm from '../components/RegisterForm';
import authService from '../services/authService'; 
import { useNavigate } from 'react-router-dom';
import { Alert } from 'react-bootstrap';

function RegisterPage({ onLogin }) {
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);
  const navigate = useNavigate();

  const handleRegister = async (userData) => {
    try {
      const user = await authService.register(userData);
      onLogin(user); // Autenticaci√≥n autom√°tica despu√©s del registro
      setSuccess('Usuario registrado y autenticado con √©xito.');
      setError(null);
      navigate('/'); // Redirige a la p√°gina principal o a donde desees
    } catch (error) {
      // Manejar errores espec√≠ficos si el backend env√≠a mensajes
      setError(error.response?.data?.msg || error.message);
      setSuccess(null);
    }
  };

  return (
    <div>
      <h1>Registrarse</h1>
      {error && <Alert variant="danger">{error}</Alert>}
      {success && <Alert variant="success">{success}</Alert>}
      <RegisterForm onRegister={handleRegister} />
    </div>
  );
}

export default RegisterPage;

----- ./frontend/src/services/authService.js -----
// frontend/src/services/authService.js
import axios from 'axios';
import { jwtDecode } from 'jwt-decode'; // Import nombrado: tu versi√≥n no exporta por defecto.

const API_URL = '/api/auth/';

const register = async (userData) => {
  try {
    const response = await axios.post(API_URL + 'register', userData);
    if (response.data.token) {
      // Decodificar el token
      const decoded = jwtDecode(response.data.token);
      const user = {
        token: response.data.token,
        id: decoded.user.id,
        role: decoded.user.role,
      };
      // Guardar en localStorage
      localStorage.setItem('user', JSON.stringify(user));
      return user;
    }
    return null;
  } catch (error) {
    console.error('Error en el registro:', error.response?.data || error.message);
    throw error;
  }
};

const login = async (credentials) => {
  try {
    const response = await axios.post(API_URL + 'login', credentials);
    if (response.data.token) {
      // Decodificar el token
      const decoded = jwtDecode(response.data.token);
      const user = {
        token: response.data.token,
        id: decoded.user.id,
        role: decoded.user.role,
      };
      // Guardar en localStorage
      localStorage.setItem('user', JSON.stringify(user));
      return user;
    }
    return null;
  } catch (error) {
    console.error('Error en el login:', error.response?.data || error.message);
    throw error;
  }
};

const logout = () => {
  localStorage.removeItem('user');
};

const getCurrentUser = () => {
  const userStr = localStorage.getItem('user');
  if (!userStr) return null;
  try {
    const user = JSON.parse(userStr);
    return user;
  } catch (error) {
    console.error('Error al parsear el usuario de localStorage:', error);
    return null;
  }
};

export default {
  register,
  login,
  logout,
  getCurrentUser,
};

----- ./backend/index.js -----
// backend/index.js

const express = require('express');
const cors = require('cors');
const dotenv = require('dotenv');
const path = require('path');
const morgan = require('morgan');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');

// Rutas
const tasksRoutes = require('./src/routes/tasks');
const uploadRoutes = require('./src/routes/upload');
const profileRoutes = require('./src/routes/profile');
const authRoutes = require('./src/routes/auth');
const usersRoutes = require('./src/routes/users');
const friendsRoutes = require('./src/routes/friends');

dotenv.config();
const app = express();
const PORT = process.env.PORT || 5000;

app.set('trust proxy', 1);
app.use(helmet());

// CORS
const allowedOrigins = ['http://localhost:3000', 'http://localhost:5000'];
app.use(
  cors({
    origin: function (origin, callback) {
      // Permitir llamadas desde herramientas internas (origin puede ser undefined)
      if (!origin) return callback(null, true);
      if (allowedOrigins.indexOf(origin) === -1) {
        const msg = `La pol√≠tica de CORS no permite el acceso desde el origen ${origin}.`;
        return callback(new Error(msg), false);
      }
      return callback(null, true);
    },
  })
);

// Rate Limit
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: 100, 
  message: 'Demasiadas solicitudes desde esta IP, por favor intenta m√°s tarde.',
});
app.use(limiter);

app.use(express.json());

if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

// Servir carpeta de uploads (para ver im√°genes subidas)
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// Rutas de la API
app.use('/api/tasks', tasksRoutes);
app.use('/api/upload', uploadRoutes);
app.use('/api/profile', profileRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/users', usersRoutes);  // se verifica dentro del propio archivo o usando authMiddleware
app.use('/api/friends', friendsRoutes); // idem

// Ruta ra√≠z
app.get('/', (req, res) => {
  res.send('API Planner2025');
});

// Manejo de rutas no encontradas
app.use((req, res, next) => {
  res.status(404).json({ error: 'Ruta no encontrada' });
});

// Manejo de errores internos
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({ error: err.message || 'Error interno del servidor' });
});

// Iniciar servidor
app.listen(PORT, () => {
  console.log(`Servidor backend corriendo en el puerto ${PORT}`);
});

----- ./backend/src/middleware/authMiddleware.js -----
// backend/src/middleware/authMiddleware.js
const jwt = require('jsonwebtoken');

module.exports = function (req, res, next) {
  const authHeader = req.header('Authorization');
  if (!authHeader) {
    return res.status(401).json({ msg: 'No hay token, autorizaci√≥n denegada' });
  }

  const token = authHeader.startsWith('Bearer ')
    ? authHeader.split(' ')[1]
    : authHeader;

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET || '123456');
    // 'decoded.user' es lo que seteamos en el payload
    req.user = decoded.user; 
    next();
  } catch (err) {
    return res.status(401).json({ msg: 'Token no v√°lido' });
  }
};

----- ./backend/src/config/db.js -----
// backend/src/config/db.js

const { Pool } = require('pg');
const dotenv = require('dotenv');

dotenv.config();

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_DATABASE,
  password: process.env.DB_PASSWORD,
  port: process.env.DB_PORT,
});

pool.on('connect', () => {
  console.log('Conectado a la base de datos PostgreSQL');
});

module.exports = pool;
----- ./backend/src/models/profile.js -----
// backend/src/models/profile.js
const User = require('./User');
const pool = require('../config/db');

const Profile = {
  getByUserId: async (userId) => {
    const { rows } = await pool.query(
      'SELECT * FROM profiles WHERE user_id = $1',
      [userId]
    );
    return rows[0] || null;
  },

  updateOrCreate: async (userId, { name, bio, profile_picture_url }) => {
    // Buscamos si hay un profile existente
    const existing = await Profile.getByUserId(userId);

    // Tomamos la info base desde "users"
    const userData = await User.findById(userId);
    const userEmail = userData.email;  
    const userNameFromUsers = userData.name; 

    // Permitimos que 'name' se pueda sobreescribir por lo que venga
    const finalName = name || userNameFromUsers;

    if (!existing) {
      // Insertar
      const insertQuery = `
        INSERT INTO profiles (user_id, name, email, bio, profile_picture_url)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING *
      `;
      const values = [
        userId,
        finalName,
        userEmail, 
        bio || '',
        profile_picture_url || '',
      ];
      const { rows } = await pool.query(insertQuery, values);
      return rows[0];
    } else {
      // Actualizar
      const updateQuery = `
        UPDATE profiles
        SET
          name = $1,
          bio = $2,
          profile_picture_url = $3,
          updated_at = now()
        WHERE user_id = $4
        RETURNING *
      `;
      const values = [
        finalName,
        bio || '',
        profile_picture_url || '',
        userId,
      ];
      const { rows } = await pool.query(updateQuery, values);
      return rows[0];
    }
  },
};

module.exports = Profile;

----- ./backend/src/models/Friend.js -----
// backend/src/models/Friend.js
const pool = require('../config/db');

const Friend = {
  /**
   * Enviar solicitud de amistad
   */
  async sendRequest(fromUserId, toUserId) {
    // Ver si ya existe una relaci√≥n (amistad o solicitud) entre ambos
    const existsQuery = `
      SELECT 1
      FROM friends
      WHERE 
        (from_user_id = $1 AND to_user_id = $2)
        OR (from_user_id = $2 AND to_user_id = $1)
    `;
    const exists = await pool.query(existsQuery, [fromUserId, toUserId]);
    if (exists.rows.length > 0) {
      // Ya existe una solicitud o amistad
      return null;
    }

    // Insertar nueva solicitud en estado 'pending'
    const insertQuery = `
      INSERT INTO friends (from_user_id, to_user_id, status, created_at, updated_at)
      VALUES ($1, $2, 'pending', NOW(), NOW())
      RETURNING *
    `;
    const values = [fromUserId, toUserId];
    const result = await pool.query(insertQuery, values);
    return result.rows[0];
  },

  /**
   * Aceptar solicitud de amistad
   */
  async acceptRequest(friendReqId, currentUserId) {
    // Solo el destinatario (to_user_id) puede aceptar
    const updateQuery = `
      UPDATE friends
        SET status = 'accepted',
            updated_at = NOW()
      WHERE id = $1
        AND to_user_id = $2
      RETURNING *
    `;
    const values = [friendReqId, currentUserId];
    const result = await pool.query(updateQuery, values);
    return result.rows[0];
  },

  /**
   * Rechazar solicitud de amistad
   */
  async rejectRequest(friendReqId, currentUserId) {
    // Solo el destinatario (to_user_id) puede rechazar
    const updateQuery = `
      UPDATE friends
        SET status = 'rejected',
            updated_at = NOW()
      WHERE id = $1
        AND to_user_id = $2
      RETURNING *
    `;
    const values = [friendReqId, currentUserId];
    const result = await pool.query(updateQuery, values);
    return result.rows[0];
  },

  /**
   * Obtener todos los amigos (relaciones en status='accepted')
   * para un usuario (userId). Se hace un JOIN para tener info de nombres y fotos.
   */
  async getFriendsOfUser(userId) {
    const query = `
      SELECT 
        f.*,
        -- Datos del usuario "from_user"
        uf.name             AS from_name,
        uf.email            AS from_email,
        pf.profile_picture_url AS from_photo,
        -- Datos del usuario "to_user"
        ut.name             AS to_name,
        ut.email            AS to_email,
        pt.profile_picture_url AS to_photo
      FROM friends f
        JOIN users uf ON f.from_user_id = uf.id
        LEFT JOIN profiles pf ON pf.user_id = uf.id
        JOIN users ut ON f.to_user_id = ut.id
        LEFT JOIN profiles pt ON pt.user_id = ut.id
      WHERE 
        (f.from_user_id = $1 OR f.to_user_id = $1)
        AND f.status = 'accepted'
      ORDER BY f.id DESC
    `;
    const { rows } = await pool.query(query, [userId]);
    return rows;
  },

  /**
   * Lista de solicitudes pendientes para un usuario (userId).
   * Se asume que userId es el "destinatario" (to_user_id).
   * JOIN para obtener nombre y foto de quien env√≠a la solicitud.
   */
  async getRequestsForUser(userId) {
    const query = `
      SELECT 
        f.*,
        uf.name  AS from_name,
        uf.email AS from_email,
        pf.profile_picture_url AS from_photo
      FROM friends f
        JOIN users uf ON f.from_user_id = uf.id
        LEFT JOIN profiles pf ON pf.user_id = uf.id
      WHERE 
        f.to_user_id = $1
        AND f.status = 'pending'
      ORDER BY f.id DESC
    `;
    const { rows } = await pool.query(query, [userId]);
    return rows;
  },

  /**
   * Buscar usuario por email o ID
   * Se hace LEFT JOIN con la tabla profiles para tambi√©n devolver la foto
   */
  async findUserByEmailOrId(queryText) {
    // El ILIKE sirve para coincidencias parciales en email
    const sql = `
      SELECT 
        u.id,
        u.name,
        u.email,
        u.role,
        p.profile_picture_url
      FROM users u
        LEFT JOIN profiles p ON p.user_id = u.id
      WHERE 
        u.email ILIKE $1
        OR CAST(u.id AS TEXT) = $2
    `;
    const values = [`%${queryText}%`, queryText];
    const { rows } = await pool.query(sql, values);
    return rows;
  },
};

module.exports = Friend;

----- ./backend/src/models/User.js -----
// backend/src/models/User.js
const pool = require('../config/db');

const User = {
  // Retorna todos los usuarios (para admin)
  async getAll() {
    const query = 'SELECT id, name, email, role FROM users ORDER BY id ASC';
    const { rows } = await pool.query(query);
    return rows;
  },

  // Obtener usuario por email
  async findByEmail(email) {
    const query = 'SELECT * FROM users WHERE email = $1';
    const { rows } = await pool.query(query, [email]);
    return rows[0];
  },

  // Obtener usuario por ID
  async findById(id) {
    const query = 'SELECT * FROM users WHERE id = $1';
    const { rows } = await pool.query(query, [id]);
    return rows[0];
  },

  // Crear usuario (usado por authController)
  async create({ name, email, password, role }) {
    const query = `
      INSERT INTO users (name, email, password, role)
      VALUES ($1, $2, $3, $4)
      RETURNING id, name, email, role
    `;
    const values = [name, email, password, role || 'user'];
    const { rows } = await pool.query(query, values);
    return rows[0];
  },

  /**
   * Actualiza SOLO el "name" (ejemplo). 
   * Si quieres m√°s campos, agrega y ajusta la consulta.
   */
  async update(id, { name }) {
    const query = `
      UPDATE users
      SET name = $1
      WHERE id = $2
      RETURNING id, name, email, role
    `;
    const values = [name, id];
    const { rows } = await pool.query(query, values);
    return rows[0] || null;
  },

  /**
   * Eliminar usuario por ID
   */
  async delete(id) {
    // Verificar si el user existe
    const existing = await this.findById(id);
    if (!existing) {
      return null;
    }
    await pool.query('DELETE FROM users WHERE id = $1', [id]);
    return existing; // o true, lo que prefieras
  },
};

module.exports = User;

----- ./backend/src/models/task.js -----
// backend/src/models/task.js
const pool = require('../config/db');

const Task = {
  // Tareas activas (admin)
  getAll: async () => {
    const { rows } = await pool.query(
      'SELECT * FROM tasks WHERE archived_at IS NULL'
    );
    return rows;
  },

  // Tareas activas (user)
  getAllByUserId: async (userId) => {
    const { rows } = await pool.query(
      'SELECT * FROM tasks WHERE archived_at IS NULL AND user_id = $1',
      [userId]
    );
    return rows;
  },

  // Obtener tarea por ID (admin)
  getById: async (id) => {
    const { rows } = await pool.query(
      'SELECT * FROM tasks WHERE id = $1',
      [id]
    );
    return rows[0];
  },

  // Obtener tarea por ID (user)
  getByIdAndUser: async (id, userId) => {
    const { rows } = await pool.query(
      'SELECT * FROM tasks WHERE id = $1 AND user_id = $2',
      [id, userId]
    );
    return rows[0];
  },

  // Crear nueva tarea
  create: async (taskData) => {
    const {
      name,
      description,
      category,
      priority,
      difficulty,
      estimated_time,
      user_id,
      status = 'Pending',
    } = taskData;

    const query = `
      INSERT INTO tasks
        (name, description, category, priority, difficulty, estimated_time, user_id, status)
      VALUES
        ($1, $2, $3, $4, $5, $6, $7, $8)
      RETURNING *
    `;

    const values = [
      name || null,
      description || null,
      category || null,
      priority || null,
      difficulty || null,
      estimated_time || null,
      user_id,
      status,
    ];

    const { rows } = await pool.query(query, values);
    return rows[0];
  },

  // Completar (status = 'Completed')
  complete: async (id) => {
    const { rows } = await pool.query(
      `UPDATE tasks 
       SET status = $1, completed_at = NOW(), updated_at = NOW() 
       WHERE id = $2 
       RETURNING *`,
      ['Completed', id]
    );
    return rows[0];
  },

  // Archivar (status = 'Archived')
  archive: async (id) => {
    const { rows } = await pool.query(
      `UPDATE tasks 
       SET status = $1, archived_at = NOW(), updated_at = NOW() 
       WHERE id = $2 
       RETURNING *`,
      ['Archived', id]
    );
    return rows[0];
  },

  // Desarchivar (status = 'Pending')
  unarchive: async (id) => {
    const { rows } = await pool.query(
      `UPDATE tasks 
       SET status = $1, archived_at = NULL, updated_at = NOW() 
       WHERE id = $2 
       RETURNING *`,
      ['Pending', id]
    );
    return rows[0];
  },

  // Actualizar
  update: async (id, taskData) => {
    const {
      name,
      description,
      category,
      priority,
      difficulty,
      status,
      completed_at,
      time_taken,
      archived_at,
      estimated_time,
      actual_time,
    } = taskData;

    const query = `
      UPDATE tasks
      SET
        name = COALESCE($1, name),
        description = COALESCE($2, description),
        category = COALESCE($3, category),
        priority = COALESCE($4, priority),
        difficulty = COALESCE($5, difficulty),
        status = COALESCE($6, status),
        completed_at = COALESCE($7, completed_at),
        time_taken = COALESCE($8, time_taken),
        archived_at = COALESCE($9, archived_at),
        estimated_time = COALESCE($10, estimated_time),
        actual_time = COALESCE($11, actual_time),
        updated_at = NOW()
      WHERE id = $12
      RETURNING *;
    `;

    const values = [
      name || null,
      description || null,
      category || null,
      priority || null,
      difficulty || null,
      status || null,
      completed_at || null,
      time_taken || null,
      archived_at || null,
      estimated_time || null,
      actual_time || null,
      id,
    ];

    const { rows } = await pool.query(query, values);
    return rows[0];
  },

  // Eliminar
  delete: async (id) => {
    await pool.query('DELETE FROM tasks WHERE id = $1', [id]);
  },

  // Tareas archivadas (admin)
  getArchivedTasks: async () => {
    const { rows } = await pool.query(
      'SELECT * FROM tasks WHERE archived_at IS NOT NULL'
    );
    return rows;
  },

  // Tareas archivadas (user)
  getArchivedTasksByUserId: async (userId) => {
    const { rows } = await pool.query(
      'SELECT * FROM tasks WHERE archived_at IS NOT NULL AND user_id = $1',
      [userId]
    );
    return rows;
  },

  // Contar todas las tareas (admin)
  countAll: async () => {
    const { rows } = await pool.query('SELECT COUNT(*) FROM tasks');
    return parseInt(rows[0].count, 10);
  },

  // Contar todas las tareas (user)
  countAllForUser: async (userId) => {
    const { rows } = await pool.query(
      'SELECT COUNT(*) FROM tasks WHERE user_id = $1',
      [userId]
    );
    return parseInt(rows[0].count, 10);
  },

  // Contar tareas por status (admin)
  countByStatus: async (status) => {
    const { rows } = await pool.query(
      'SELECT COUNT(*) FROM tasks WHERE status = $1',
      [status]
    );
    return parseInt(rows[0].count, 10);
  },

  // Contar tareas por status (user)
  countByStatusForUser: async (status, userId) => {
    const { rows } = await pool.query(
      'SELECT COUNT(*) FROM tasks WHERE status = $1 AND user_id = $2',
      [status, userId]
    );
    return parseInt(rows[0].count, 10);
  },
};

module.exports = Task;

----- ./backend/src/controllers/friendsController.js -----
// backend/src/controllers/friendsController.js
const Friend = require('../models/Friend');
const { validationResult } = require('express-validator');

const friendsController = {
  // Enviar solicitud de amistad
  sendRequest: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }
    try {
      const fromUserId = req.user.id;
      const { to_user_id } = req.body;
      const friendReq = await Friend.sendRequest(fromUserId, to_user_id);

      if (!friendReq) {
        return res
          .status(400)
          .json({ error: 'Ya existe una solicitud o amistad con ese usuario.' });
      }
      res.json(friendReq);
    } catch (error) {
      console.error('Error al enviar solicitud de amistad:', error);
      res.status(500).json({ error: 'Error al enviar solicitud de amistad' });
    }
  },

  // Aceptar solicitud
  acceptRequest: async (req, res) => {
    try {
      const friendReqId = req.params.id;
      const userId = req.user.id;
      const updated = await Friend.acceptRequest(friendReqId, userId);
      if (!updated) {
        return res.status(404).json({
          error: 'Solicitud no encontrada o no eres el destinatario.',
        });
      }
      res.json(updated);
    } catch (error) {
      console.error('Error al aceptar solicitud:', error);
      res.status(500).json({ error: 'Error al aceptar solicitud' });
    }
  },

  // Rechazar solicitud
  rejectRequest: async (req, res) => {
    try {
      const friendReqId = req.params.id;
      const userId = req.user.id;
      const updated = await Friend.rejectRequest(friendReqId, userId);
      if (!updated) {
        return res.status(404).json({
          error: 'Solicitud no encontrada o no eres el destinatario.',
        });
      }
      res.json(updated);
    } catch (error) {
      console.error('Error al rechazar solicitud:', error);
      res.status(500).json({ error: 'Error al rechazar solicitud' });
    }
  },

  // Lista de amigos (aceptados)
  getMyFriends: async (req, res) => {
    try {
      const userId = req.user.id;
      const friends = await Friend.getFriendsOfUser(userId);
      res.json(friends);
    } catch (error) {
      console.error('Error al obtener amigos:', error);
      res.status(500).json({ error: 'Error al obtener amigos' });
    }
  },

  // Lista de solicitudes pendientes
  getMyRequests: async (req, res) => {
    try {
      const userId = req.user.id;
      const requests = await Friend.getRequestsForUser(userId);
      res.json(requests);
    } catch (error) {
      console.error('Error al obtener solicitudes:', error);
      res.status(500).json({ error: 'Error al obtener solicitudes' });
    }
  },

  // Buscar usuario por email o id
  searchUser: async (req, res) => {
    try {
      const { query } = req.query; // ?query=...
      if (!query) return res.json([]);
      const users = await Friend.findUserByEmailOrId(query);
      res.json(users);
    } catch (error) {
      console.error('Error al buscar usuario:', error);
      res.status(500).json({ error: 'Error al buscar usuario' });
    }
  },
};

module.exports = friendsController;

----- ./backend/src/controllers/userController.js -----
// backend/src/controllers/userController.js
const User = require('../models/User');

/**
 * CONTROLADOR de usuarios (solo para ADMIN), con getAll, getById, update, delete
 * NOTA: la creaci√≥n de usuarios se hace en authController (register).
 */
const userController = {
  /**
   * Listar todos los usuarios
   */
  getAllUsers: async (req, res) => {
    try {
      // OJO: asumes que req.user.role === 'admin' (middleware lo permite). 
      const users = await User.getAll();
      res.json(users);
    } catch (error) {
      console.error('Error al obtener todos los usuarios:', error.message);
      res.status(500).json({ msg: 'Error del servidor' });
    }
  },

  /**
   * Obtener un usuario por ID
   */
  getUserById: async (req, res) => {
    try {
      const user = await User.findById(req.params.id);
      if (!user) {
        return res.status(404).json({ msg: 'Usuario no encontrado' });
      }
      res.json(user);
    } catch (error) {
      console.error('Error al obtener usuario por ID:', error.message);
      res.status(500).json({ msg: 'Error del servidor' });
    }
  },

  /**
   * Actualizar usuario (solo admin). 
   * - Por simplicidad, solo actualiza "name" en la tabla users.
   * - Si quisieras actualizar "email", ad√°ptalo a tu gusto.
   */
  updateUser: async (req, res) => {
    try {
      const { name } = req.body; // ajusta si deseas actualizar m√°s campos
      if (!name) {
        return res.status(400).json({ msg: 'Se requiere un nombre para actualizar.' });
      }

      const updatedUser = await User.update(req.params.id, { name });
      if (!updatedUser) {
        return res.status(404).json({ msg: 'Usuario no encontrado o no se actualiz√≥' });
      }
      res.json(updatedUser);
    } catch (error) {
      console.error('Error al actualizar usuario:', error.message);
      res.status(500).json({ msg: 'Error del servidor' });
    }
  },

  /**
   * Eliminar usuario (solo admin).
   */
  deleteUser: async (req, res) => {
    try {
      const deletedUser = await User.delete(req.params.id);
      if (!deletedUser) {
        return res.status(404).json({ msg: 'Usuario no encontrado' });
      }
      res.json({ msg: 'Usuario eliminado' });
    } catch (error) {
      console.error('Error al eliminar usuario:', error.message);
      res.status(500).json({ msg: 'Error del servidor' });
    }
  },
};

module.exports = userController;

----- ./backend/src/controllers/tasksController.js -----
// backend/src/controllers/tasksController.js
const Task = require('../models/task');
const { validationResult } = require('express-validator');

const tasksController = {
  // Obtener todas las tareas (no archivadas)
  getAllTasks: async (req, res) => {
    try {
      // req.user viene del authMiddleware con { id, role, ... }
      let tasks;
      if (req.user.role === 'admin') {
        tasks = await Task.getAll(); 
      } else {
        tasks = await Task.getAllByUserId(req.user.id);
      }
      res.json(tasks);
    } catch (error) {
      console.error('Error al obtener tareas:', error);
      res.status(500).json({ error: 'Error al obtener las tareas' });
    }
  },

  // Obtener tareas archivadas
  getArchivedTasks: async (req, res) => {
    try {
      let tasks;
      if (req.user.role === 'admin') {
        tasks = await Task.getArchivedTasks();
      } else {
        tasks = await Task.getArchivedTasksByUserId(req.user.id);
      }
      res.json(tasks);
    } catch (error) {
      console.error('Error al obtener tareas archivadas:', error);
      res.status(500).json({ error: 'Error al obtener tareas archivadas' });
    }
  },

  // Obtener una tarea concreta por ID
  getTaskById: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      let task;
      if (req.user.role === 'admin') {
        task = await Task.getById(req.params.id);
      } else {
        task = await Task.getByIdAndUser(req.params.id, req.user.id);
      }

      if (!task) {
        return res.status(404).json({ error: 'Tarea no encontrada' });
      }
      res.json(task);
    } catch (error) {
      console.error('Error al obtener la tarea:', error);
      res.status(500).json({ error: 'Error al obtener la tarea' });
    }
  },

  // Crear una nueva tarea
  createTask: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      // Asignar user_id al body para forzar que la tarea sea del usuario logueado
      const taskData = {
        ...req.body,
        user_id: req.user.id,
      };
      const newTask = await Task.create(taskData);
      return res.status(201).json(newTask);
    } catch (error) {
      console.error('Error al crear la tarea:', error);
      res.status(500).json({ error: 'Error al crear la tarea' });
    }
  },

  // Completar una tarea (status => 'Completed')
  completeTask: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      let task;
      if (req.user.role === 'admin') {
        task = await Task.getById(req.params.id);
      } else {
        task = await Task.getByIdAndUser(req.params.id, req.user.id);
      }
      if (!task) {
        return res.status(404).json({ error: 'Tarea no encontrada' });
      }
      const updatedTask = await Task.complete(req.params.id);
      res.json(updatedTask);
    } catch (error) {
      console.error('Error al completar la tarea:', error);
      res.status(500).json({ error: 'Error al completar la tarea' });
    }
  },

  // Archivar una tarea (status => 'Archived')
  archiveTask: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      let task;
      if (req.user.role === 'admin') {
        task = await Task.getById(req.params.id);
      } else {
        task = await Task.getByIdAndUser(req.params.id, req.user.id);
      }
      if (!task) {
        return res.status(404).json({ error: 'Tarea no encontrada' });
      }
      const updatedTask = await Task.archive(req.params.id);
      res.json(updatedTask);
    } catch (error) {
      console.error('Error al archivar la tarea:', error);
      res.status(500).json({ error: 'Error al archivar la tarea' });
    }
  },

  // Desarchivar una tarea (status => 'Pending')
  unarchiveTask: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      let task;
      if (req.user.role === 'admin') {
        task = await Task.getById(req.params.id);
      } else {
        task = await Task.getByIdAndUser(req.params.id, req.user.id);
      }
      if (!task) {
        return res.status(404).json({ error: 'Tarea no encontrada' });
      }
      const updatedTask = await Task.unarchive(req.params.id);
      res.json(updatedTask);
    } catch (error) {
      console.error('Error al desarchivar la tarea:', error);
      res.status(500).json({ error: 'Error al desarchivar la tarea' });
    }
  },

  // Actualizar una tarea
  updateTask: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      let task;
      if (req.user.role === 'admin') {
        task = await Task.getById(req.params.id);
      } else {
        task = await Task.getByIdAndUser(req.params.id, req.user.id);
      }
      if (!task) {
        return res.status(404).json({ error: 'Tarea no encontrada' });
      }

      const updatedTask = await Task.update(req.params.id, req.body);
      res.json(updatedTask);
    } catch (error) {
      console.error('Error al actualizar la tarea:', error);
      res.status(500).json({ error: 'Error al actualizar la tarea' });
    }
  },

  // Eliminar una tarea
  deleteTask: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      let task;
      if (req.user.role === 'admin') {
        task = await Task.getById(req.params.id);
      } else {
        task = await Task.getByIdAndUser(req.params.id, req.user.id);
      }
      if (!task) {
        return res.status(404).json({ error: 'Tarea no encontrada' });
      }

      await Task.delete(req.params.id);
      res.json({ message: 'Tarea eliminada' });
    } catch (error) {
      console.error('Error al eliminar la tarea:', error);
      res.status(500).json({ error: 'Error al eliminar la tarea' });
    }
  },

  /**
   * Estad√≠sticas. Devuelve un JSON con:
   *  {
   *    totalTasks,
   *    completed,
   *    pending,
   *    inProgress
   *  }
   *  Si quieres un stacked chart, necesitar√°s un group by (priority,difficulty).
   */
  getStats: async (req, res) => {
    try {
      let totalTasks, completed, pending, inProgress;

      if (req.user.role === 'admin') {
        totalTasks = await Task.countAll();
        completed = await Task.countByStatus('Completed');
        pending = await Task.countByStatus('Pending');
        inProgress = await Task.countByStatus('In Progress');
      } else {
        totalTasks = await Task.countAllForUser(req.user.id);
        completed = await Task.countByStatusForUser('Completed', req.user.id);
        pending = await Task.countByStatusForUser('Pending', req.user.id);
        inProgress = await Task.countByStatusForUser('In Progress', req.user.id);
      }

      // EJEMPLO: Si deseas stackedData (priority vs difficulty),
      // deber√≠as hacer un m√©todo en Task que agrupe y devuelva 
      // { priority, difficulty, total }. Lo omito aqu√≠ por brevedad.

      // Devolvemos el JSON (compatible con tu TaskMetricsPage actual)
      return res.json({
        totalTasks,
        completed,
        pending,
        inProgress,
      });
    } catch (error) {
      console.error('Error al obtener estad√≠sticas:', error);
      res.status(500).json({ error: 'Error al obtener estad√≠sticas' });
    }
  },
};

module.exports = tasksController;

----- ./backend/src/controllers/profileController.js -----
// backend/src/controllers/profileController.js
const fs = require('fs');
const path = require('path');
const { validationResult } = require('express-validator');
const Profile = require('../models/profile');
const User = require('../models/User');

const profileController = {
  /**
   * GET /api/profile
   * Retorna el perfil del usuario logueado, o si no existe en "profiles",
   * retorna datos b√°sicos desde la tabla "users".
   */
  getProfile: async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res
          .status(401)
          .json({ error: 'No se encontr√≥ ID de usuario en el token' });
      }

      // Buscar si existe profile
      const profile = await Profile.getByUserId(userId);

      if (!profile) {
        // Si no existe, retornamos info b√°sica de la tabla users
        const userData = await User.findById(userId);
        if (!userData) {
          return res.status(404).json({ error: 'Usuario no encontrado' });
        }
        return res.json({
          user_id: userId,
          name: userData.name,
          email: userData.email,
          bio: '',
          profile_picture_url: '',
        });
      } else {
        // Existe profile en la BD
        return res.json(profile);
      }
    } catch (error) {
      console.error('Error al obtener el perfil:', error);
      res.status(500).json({ error: 'Error al obtener el perfil' });
    }
  },

  /**
   * PUT /api/profile
   * Actualiza (o crea) el perfil. 
   * Si el profile_picture_url cambi√≥, borra la imagen anterior.
   */
  updateProfile: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: 'Usuario no autenticado' });
      }

      const { name, bio, profile_picture_url } = req.body;

      // 1) Obtener el perfil actual para ver si hay que borrar la imagen anterior
      const existingProfile = await Profile.getByUserId(userId);

      // 2) Si existe y la "profile_picture_url" es distinta & no vac√≠a
      if (
        existingProfile &&
        existingProfile.profile_picture_url &&
        existingProfile.profile_picture_url.trim() !== '' &&
        existingProfile.profile_picture_url !== profile_picture_url
      ) {
        const oldUrl = existingProfile.profile_picture_url;
        // Basename extrae '12345.png' de 'http://localhost:5000/uploads/12345.png'
        const filename = path.basename(oldUrl);
        const filePath = path.join(__dirname, '../../uploads', filename);

        fs.unlink(filePath, (err) => {
          if (err) {
            console.error('Error al borrar imagen anterior:', err);
          } else {
            console.log('Imagen anterior borrada con √©xito:', filename);
          }
        });
      }

      // 3) Llamar a updateOrCreate => lo que ya hac√≠as
      const updated = await Profile.updateOrCreate(userId, {
        name,
        bio,
        profile_picture_url,
      });

      return res.json(updated);
    } catch (error) {
      console.error('Error al actualizar el perfil:', error);
      return res.status(500).json({ error: 'Error al actualizar el perfil' });
    }
  },
};

module.exports = profileController;

----- ./backend/src/controllers/authController.js -----
// backend/src/controllers/authController.js
const User = require('../models/User');
const Profile = require('../models/profile'); // <-- Importamos el modelo Profile
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const { validationResult } = require('express-validator');

const authController = {
  register: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { name, email, password } = req.body; // Eliminamos 'role' aqu√≠

    try {
      let user = await User.findByEmail(email);
      if (user) {
        return res.status(400).json({ msg: 'El usuario ya existe' });
      }

      // Hashear password
      const salt = await bcrypt.genSalt(10);
      const hashedPassword = await bcrypt.hash(password, salt);

      // Crear usuario con rol 'user' por defecto
      user = await User.create({
        name,
        email,
        password: hashedPassword,
        role: 'user',
      });

      // Justo despu√©s de crear el user, creamos su profile en la tabla "profiles"
      // Usamos updateOrCreate para no duplicar si existiera
      await Profile.updateOrCreate(user.id, {
        name: user.name,             // inicializamos con su name de la tabla users
        bio: '',                     // vac√≠o por defecto
        profile_picture_url: '',     // vac√≠o al inicio
      });

      // Generar token
      const payload = {
        user: {
          id: user.id,
          role: user.role,
        },
      };

      jwt.sign(
        payload,
        process.env.JWT_SECRET || '123456',
        { expiresIn: '1h' },
        (err, token) => {
          if (err) throw err;
          res.json({ token });
        }
      );
    } catch (error) {
      console.error(error.message);
      res.status(500).send('Error del servidor');
    }
  },

  login: async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const { email, password } = req.body;

    try {
      let user = await User.findByEmail(email);
      if (!user) {
        return res.status(400).json({ msg: 'Credenciales inv√°lidas' });
      }

      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) {
        return res.status(400).json({ msg: 'Credenciales inv√°lidas' });
      }

      const payload = {
        user: {
          id: user.id,
          role: user.role,
        },
      };

      jwt.sign(
        payload,
        process.env.JWT_SECRET || '123456',
        { expiresIn: '1h' },
        (err, token) => {
          if (err) throw err;
          res.json({ token });
        }
      );
    } catch (error) {
      console.error(error.message);
      res.status(500).send('Error del servidor');
    }
  },

  // (Opcional) Verificar token si deseas un endpoint /verify
  verifyToken: (req, res) => {
    const token = req.body.token;
    if (!token) {
      return res.status(400).json({ msg: 'No token in request' });
    }
    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET || '123456');
      return res.json({ user: decoded.user });
    } catch (error) {
      return res.status(401).json({ msg: 'Token inv√°lido' });
    }
  },
};

module.exports = authController;

----- ./backend/src/routes/profile.js -----
// backend/src/routes/profile.js
const express = require('express');
const router = express.Router();
const profileController = require('../controllers/profileController');
const authMiddleware = require('../middleware/authMiddleware');
const { body } = require('express-validator');

// Proteger rutas
router.use(authMiddleware);

// Obtener el perfil
router.get('/', profileController.getProfile);

// Actualizar el perfil
router.put(
  '/',
  [
    body('name').isLength({ min: 1 }).withMessage('El nombre es obligatorio.'),
    body('bio').optional().isString(),
    body('profile_picture_url').optional().isString(),
  ],
  profileController.updateProfile
);

module.exports = router;

----- ./backend/src/routes/auth.js -----
// backend/src/routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const { body } = require('express-validator');

// Registro de usuario
router.post(
  '/register',
  [
    body('name', 'Por favor, introduce un nombre').not().isEmpty(),
    body('email', 'Por favor, introduce un email v√°lido').isEmail(),
    body('password', 'La contrase√±a debe tener al menos 6 caracteres').isLength({
      min: 6,
    }),
  ],
  authController.register
);

// Inicio de sesi√≥n
router.post(
  '/login',
  [
    body('email', 'Por favor, introduce un email v√°lido').isEmail(),
    body('password', 'La contrase√±a es obligatoria').exists(),
  ],
  authController.login
);

// (Opcional) Verificar token
router.post('/verify', authController.verifyToken);

module.exports = router;

----- ./backend/src/routes/users.js -----
// backend/src/routes/users.js
const express = require('express');
const router = express.Router();
const userController = require('../controllers/userController');
const authMiddleware = require('../middleware/authMiddleware');

// Aplicar middleware a todas las rutas
router.use(authMiddleware);

// Obtener todos los usuarios (solo admin)
router.get('/', userController.getAllUsers);

// Obtener un usuario por ID (solo admin)
router.get('/:id', userController.getUserById);

// Actualizar un usuario (solo admin)
router.put('/:id', userController.updateUser);

// Eliminar un usuario (solo admin)
router.delete('/:id', userController.deleteUser);

module.exports = router;

----- ./backend/src/routes/upload.js -----
// backend/src/routes/upload.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const dotenv = require('dotenv');

dotenv.config();

// Configuraci√≥n de almacenamiento con multer
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + path.extname(file.originalname));
  },
});

// Filtro de archivos para solo im√°genes
const fileFilter = (req, file, cb) => {
  const allowedTypes = /jpeg|jpg|png|gif/;
  const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
  const mimetype = allowedTypes.test(file.mimetype);
  if (mimetype && extname) {
    cb(null, true);
  } else {
    cb(new Error('Solo se permiten im√°genes (jpeg, jpg, png, gif)'));
  }
};

const upload = multer({
  storage,
  limits: { fileSize: 5 * 1024 * 1024 }, // 5MB
  fileFilter,
});

// Ruta para subir una imagen de perfil
router.post('/profile-picture', upload.single('profilePicture'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No se subi√≥ ning√∫n archivo' });
  }
  const baseUrl = process.env.BASE_URL || 'http://localhost:5000';
  const imageUrl = `${baseUrl}/uploads/${req.file.filename}`;
  res.json({ imageUrl });
});

module.exports = router;

----- ./backend/src/routes/friends.js -----
// backend/src/routes/friends.js
const express = require('express');
const router = express.Router();
const friendController = require('../controllers/friendsController');
const authMiddleware = require('../middleware/authMiddleware');
const { body, query, param } = require('express-validator');

// Todas requieren auth
router.use(authMiddleware);

// Buscar usuarios
router.get(
  '/search',
  [query('query').notEmpty().withMessage('Debe proporcionar un ID o email')],
  friendController.searchUser
);

// Listar amigos
router.get('/list', friendController.getMyFriends);

// Listar solicitudes pendientes
router.get('/requests', friendController.getMyRequests);

// Enviar solicitud
router.post(
  '/send',
  [body('to_user_id').isInt().withMessage('to_user_id debe ser entero')],
  friendController.sendRequest
);

// Aceptar
router.put('/:id/accept', friendController.acceptRequest);

// Rechazar
router.put('/:id/reject', friendController.rejectRequest);

module.exports = router;

----- ./backend/src/routes/tasks.js -----
// backend/src/routes/tasks.js
const express = require('express');
const router = express.Router();
const tasksController = require('../controllers/tasksController');
const authMiddleware = require('../middleware/authMiddleware');
const { body, param } = require('express-validator');

// Todas estas rutas requieren auth
router.use(authMiddleware);

// Tareas archivadas
router.get('/archived', tasksController.getArchivedTasks);

// Estad√≠sticas
router.get('/stats', tasksController.getStats);

// Todas las tareas activas
router.get('/', tasksController.getAllTasks);

// Obtener una tarea por ID
router.get(
  '/:id',
  [param('id').isInt().withMessage('ID de tarea debe ser un n√∫mero entero.')],
  tasksController.getTaskById
);

// Crear nueva tarea
router.post(
  '/',
  [
    body('name').isLength({ min: 1 }).withMessage('El nombre es obligatorio.'),
    body('description').optional().isString(),
    body('priority')
      .isIn(['Low', 'Medium', 'High'])
      .withMessage('Prioridad inv√°lida.'),
    body('difficulty')
      .isInt({ min: 1, max: 3 })
      .withMessage('La dificultad debe ser 1, 2 o 3.'),
    body('status')
      .isIn(['Pending', 'In Progress', 'Completed'])
      .withMessage('Estado inv√°lido.'),
    body('estimated_time')
      .optional()
      .isFloat({ min: 0 })
      .withMessage('Tiempo estimado debe ser >= 0.'),
    body('actual_time')
      .optional()
      .isFloat({ min: 0 })
      .withMessage('Tiempo real debe ser >= 0.'),
  ],
  tasksController.createTask
);

// Completar tarea
router.put(
  '/:id/complete',
  [param('id').isInt().withMessage('ID debe ser entero')],
  tasksController.completeTask
);

// Archivar tarea
router.put(
  '/:id/archive',
  [param('id').isInt().withMessage('ID debe ser entero')],
  tasksController.archiveTask
);

// Desarchivar tarea
router.put(
  '/:id/unarchive',
  [param('id').isInt().withMessage('ID debe ser entero')],
  tasksController.unarchiveTask
);

// Actualizar tarea
router.put(
  '/:id',
  [
    param('id').isInt().withMessage('ID debe ser entero'),
    body('name')
      .optional()
      .isLength({ min: 1 })
      .withMessage('Nombre no puede estar vac√≠o.'),
    body('description').optional().isString(),
    body('priority')
      .optional()
      .isIn(['Low', 'Medium', 'High'])
      .withMessage('Prioridad inv√°lida.'),
    body('difficulty').optional().isInt({ min: 1, max: 3 }),
    body('status')
      .optional()
      .isIn(['Pending', 'In Progress', 'Completed', 'Archived'])
      .withMessage('Estado inv√°lido.'),
    body('estimated_time').optional().isFloat({ min: 0 }),
    body('actual_time').optional().isFloat({ min: 0 }),
  ],
  tasksController.updateTask
);

// Eliminar tarea
router.delete(
  '/:id',
  [param('id').isInt().withMessage('ID debe ser entero')],
  tasksController.deleteTask
);

module.exports = router;
